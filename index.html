<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NEtwings ‚Äî –¢—Ä–∞—Ñ–∞—Ä–µ—Ç + –ø—Ä–æ–µ–∫—Ç—ã + –ø—Ä–∏–≤—è–∑–∫–∞ (2 —Ç–æ—á–∫–∏) + –ª–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>

  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #app { height: 100%; display: grid; grid-template-columns: 520px 1fr; }
    #sidebar { padding: 14px; overflow: auto; border-right: 1px solid #e5e5e5; background: #fff; }
    #map { height: 100%; }

    h1 { font-size: 18px; margin: 0 0 10px; font-weight: 900; }
    .muted { color:#666; font-size: 12px; line-height: 1.35; }

    .card { border:1px solid #eee; border-radius: 12px; padding: 12px; margin: 12px 0; background:#fafafa; }
    .label { font-weight: 900; margin: 0 0 8px; font-size: 13px; }
    .small { font-size: 12px; color:#666; line-height: 1.35; }

    .btn { padding: 10px 12px; border:1px solid #ddd; border-radius: 10px; background:#fff; cursor:pointer; font-weight: 800; font-size: 13px; width: 100%; text-align:left; }
    .btn.primary { border-color:#2f6fed; color:#2f6fed; }
    .btn + .btn { margin-top: 8px; }

    input[type="range"] { width:100%; }
    input[type="text"], select { width:100%; padding:10px; border:1px solid #ddd; border-radius:10px; font-size:13px; background:#fff; }
    textarea { width:100%; height: 150px; border:1px solid #ddd; border-radius:10px; padding:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px; }

    #layersList { max-height: 320px; overflow-y: auto; padding-right: 6px; }

    .layerItem { background:#fff; border: 1px solid #e8e8e8; border-radius: 12px; padding: 10px; margin-bottom: 10px; cursor: pointer; transition: 0.15s; }
    .layerItem:hover { border-color:#cfcfcf; }
    .layerItem.active { border: 2px solid #ff7a00; background: #fff5ea; }
    .layerTop { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 8px; }
    .layerName { font-weight: 900; font-size: 13px; }
    .pill { font-size: 11px; padding: 4px 8px; border-radius: 999px; border:1px solid #ddd; background:#fafafa; color:#555; white-space: nowrap; }

    .row { display:flex; gap: 8px; flex-wrap: wrap; }
    .mini { padding: 8px 10px; border-radius: 10px; border:2px solid #ddd; background:#fff; cursor:pointer; font-weight: 900; font-size: 12px; flex: 1 1 auto; text-align: center; }
    .mini.primary { border-color:#2f6fed; color:#2f6fed; }
    .mini.danger { border-color:#e5484d; color:#e5484d; }
    .mini.ok { border-color:#1a7f37; color:#1a7f37; }
    .mini.active { outline: 2px solid #111; }

    .zones { display:flex; gap:8px; flex-wrap: wrap; }
    .zonebtn { flex:1 1 46%; border-radius: 10px; padding: 10px; border:2px solid #ddd; cursor:pointer; font-weight: 900; background:#fff; }
    .zonebtn.active { outline: 2px solid #111; }

    .toast { position: fixed; left: 12px; bottom: 12px; z-index: 999999; background: rgba(20,20,20,0.92); color: #fff;
      padding: 10px 12px; border-radius: 12px; font-size: 12px; display:none; max-width: 680px; }

    .warn { background:#fff2f2; border:1px solid #ffd1d1; color:#8a1f1f; padding:10px; border-radius:10px; font-size:12px; margin-top:10px; display:none; }

    /* Calibration modal */
    #calModal { display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:999999; }
    #calBox { max-width:1100px; margin:18px auto; background:#fff; border-radius:14px; padding:14px; }
    .calTop { display:flex; justify-content:space-between; gap:10px; align-items:center; }
    #calViewport { margin-top:10px; border:1px solid #eee; border-radius:12px; overflow:hidden; height:74vh; background:#f7f7f7; }
    #calStage { width:100%; height:100%; position:relative; touch-action:none; cursor:grab; }
    #calImg { position:absolute; left:0; top:0; transform-origin:0 0; user-select:none; -webkit-user-drag:none; }

    /* markers on screen */
    .calMark {
      position:absolute;
      width: 14px; height: 14px;
      border-radius: 999px;
      border: 3px solid #111;
      background: rgba(255,255,255,0.9);
      transform: translate(-50%, -50%);
      pointer-events:none;
      display:none;
      z-index: 10;
    }
    .calMark.red { border-color:#ff2d2d; }
    .calMark.blue { border-color:#2f6fed; }
    .calMarkLabel {
      position:absolute;
      transform: translate(10px, -14px);
      font-size: 12px;
      font-weight: 900;
      color:#111;
      background: rgba(255,255,255,0.85);
      padding: 2px 6px;
      border-radius: 8px;
      border:1px solid #eee;
      pointer-events:none;
      white-space:nowrap;
    }
  </style>
</head>
<body>

<div id="app">
  <div id="sidebar">
    <h1>–¢—Ä–∞—Ñ–∞—Ä–µ—Ç ‚Üí –ø—Ä–∏–≤—è–∑–∫–∞ ‚Üí —Ñ–∞—Å–∞–¥—ã</h1>
    <div class="muted">
      ‚Ä¢ –ü—Ä–æ–µ–∫—Ç—ã = —Ä–∞–∑–Ω—ã–µ –Ω–∞–±–æ—Ä—ã —Å–ª–æ—ë–≤ (–ü—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å / –ü–ª–æ—Ç–Ω–æ—Å—Ç—å –Ω–∞—Å–µ–ª–µ–Ω–∏—è / ‚Ä¶)<br>
      ‚Ä¢ –¢—Ä–∞—Ñ–∞—Ä–µ—Ç –¥–≤–∏–≥–∞–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–∏–≤—è–∑–∫–æ–π (2 —Ç–æ—á–∫–∏).<br>
      ‚Ä¢ –£–¥–∞–ª–∏—Ç—å –∑–æ–Ω—É: Shift+–∫–ª–∏–∫, –ü–ö–ú –∏–ª–∏ –≤—ã–¥–µ–ª–∏—Ç—å –õ–ö–ú –∏ –Ω–∞–∂–∞—Ç—å Delete.
    </div>
    <div id="protoWarn" class="warn"></div>

    <div class="card">
      <div class="label">–ü—Ä–æ–µ–∫—Ç—ã (–Ω–∞–±–æ—Ä—ã —Å–ª–æ—ë–≤)</div>
      <select id="projectSelect"></select>
      <div class="row" style="margin-top:10px">
        <button class="mini primary" id="projNew">Ôºã –ù–æ–≤—ã–π</button>
        <button class="mini" id="projRename">‚úèÔ∏è –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å</button>
        <button class="mini danger" id="projDelete">üóë –£–¥–∞–ª–∏—Ç—å</button>
      </div>
      <div class="small" style="margin-top:8px">
        –ü—Ä–∏–º–µ—Ä: ¬´–ü—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å¬ª, ¬´–ü–ª–æ—Ç–Ω–æ—Å—Ç—å –Ω–∞—Å–µ–ª–µ–Ω–∏—è¬ª, ¬´–†–µ—Å—Ç–æ—Ä–∞–Ω–Ω—ã–µ —É–ª–∏—Ü—ã¬ª.
      </div>
    </div>

    <div class="card">
      <div class="label">–¢—Ä–∞—Ñ–∞—Ä–µ—Ç—ã (—Å–∫—Ä–∏–Ω—ã)</div>
      <button class="btn primary" id="btnAddLayers">üñº –î–æ–±–∞–≤–∏—Ç—å —Å–∫—Ä–∏–Ω(—ã)</button>
      <input id="imgFiles" type="file" accept="image/*" multiple style="display:none">
      <div style="margin-top:10px" id="layersList"></div>
      <div class="small" style="margin-top:8px">
        –î–≤–∏–∂–µ–Ω–∏–µ/–º–∞—Å—à—Ç–∞–± —Ç—Ä–∞—Ñ–∞—Ä–µ—Ç–∞ –Ω–∞ –∫–∞—Ä—Ç–µ –æ—Ç–∫–ª—é—á–µ–Ω—ã ‚Äî —Ç–æ–ª—å–∫–æ –ø—Ä–∏–≤—è–∑–∫–∞ –ø–æ 2 —Ç–æ—á–∫–∞–º.
      </div>
    </div>

    <div class="card">
      <div class="label">–ü—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å (—É—Ä–æ–≤–µ–Ω—å)</div>
      <div class="zones">
        <button class="zonebtn" id="zGreat"  style="border-color:#ff2d2d;">üî¥ 1000+ /—á</button>
        <button class="zonebtn" id="zNormal" style="border-color:#ff8a00;">üü† 500‚Äì1000 /—á</button>
        <button class="zonebtn" id="zMedium" style="border-color:#ffd400;">üü° 100‚Äì500 /—á</button>
        <button class="zonebtn" id="zLow"    style="border-color:#39c16c;">üü¢ 0‚Äì100 /—á</button>
      </div>
      <div class="small" style="margin-top:8px">
        –°–µ–π—á–∞—Å: <b id="stateLine">–≤—ã–∫–ª—é—á–µ–Ω–æ</b>
      </div>
    </div>

    <div class="card">
      <div class="label">–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º</div>
      <input id="coordInput" type="text" placeholder="–ü—Ä–∏–º–µ—Ä: 30.6228149999999,59.7390690000000">
      <button class="btn primary" id="btnCheckCoords" style="margin-top:10px">üîé –ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
      <div class="small" id="coordResult" style="margin-top:8px">–í–≤–µ–¥–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ —Ñ–æ—Ä–º–∞—Ç–µ <b>lng,lat</b>.</div>
    </div>

    <div class="card">
      <div class="label">–õ–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞ (–¥–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω—è—è –∑–æ–Ω–∞)</div>

      <div style="margin-top:10px">
        <div class="small">–®–∏—Ä–∏–Ω–∞ –∑–∞—Ö–≤–∞—Ç–∞ —Ñ–∞—Å–∞–¥–∞ (–º)</div>
        <input id="streetWidth" type="text" value="15">
      </div>

      <button class="btn primary" id="btnStreetMode" style="margin-top:10px">üñä –í–∫–ª—é—á–∏—Ç—å –ª–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞</button>
      <div class="small" style="margin-top:8px">–†–∏—Å–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è, –ø–æ–∫–∞ –Ω–µ –Ω–∞–∂–º—ë—à—å Esc –∏–ª–∏ –Ω–µ –≤—ã–∫–ª—é—á–∏—à—å –∫–Ω–æ–ø–∫—É.</div>
    </div>

    <div class="card">
      <div class="label">–≠–∫—Å–ø–æ—Ä—Ç / –∏–º–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã (JSON)</div>
      <div class="row">
        <button class="btn" id="btnExport">‚¨áÔ∏è –≠–∫—Å–ø–æ—Ä—Ç</button>
        <button class="btn" id="btnImport">‚¨ÜÔ∏è –ò–º–ø–æ—Ä—Ç</button>
      </div>
      <input id="importFile" type="file" accept=".json,.geojson,application/json,application/geo+json" style="display:none">
      <textarea id="geojsonBox" spellcheck="false" style="margin-top:10px"></textarea>
    </div>
  </div>

  <div id="map"></div>
</div>

<div id="toast" class="toast"></div>

<!-- Calibration modal -->
<div id="calModal">
  <div id="calBox">
    <div class="calTop">
      <div style="font-weight:900">üéØ –ü—Ä–∏–≤—è–∑–∫–∞: –æ—Ç–º–µ—Ç—å —Ç–æ—á–∫–∏ –Ω–∞ —Å–∫—Ä–∏–Ω–µ</div>
      <button id="calClose" class="btn" style="width:auto">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
    <div class="small" id="calHint" style="margin-top:8px"></div>

    <div class="row" style="margin-top:10px">
      <button id="calZoomIn" class="mini primary" style="flex:0 0 auto;">Ôºã</button>
      <button id="calZoomOut" class="mini primary" style="flex:0 0 auto;">Ôºç</button>
      <button id="calZoomFit" class="mini" style="flex:0 0 auto;">–í–ø–∏—Å–∞—Ç—å</button>
      <div class="small" style="align-self:center;">–ö–æ–ª—ë—Å–∏–∫–æ: zoom ‚Ä¢ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ: pan ‚Ä¢ –∫–ª–∏–∫: –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–æ—á–∫—É</div>
    </div>

    <div id="calViewport">
      <div id="calStage">
        <img id="calImg" />
        <div id="markA" class="calMark blue"><div class="calMarkLabel">A</div></div>
        <div id="markB" class="calMark red"><div class="calMarkLabel">B</div></div>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

<script>
  // ========= file:// warning =========
  const protoWarn = document.getElementById("protoWarn");
  if (location.protocol === "file:") {
    protoWarn.style.display = "block";
    protoWarn.innerHTML = `
      –û—Ç–∫—Ä—ã—Ç–æ –∫–∞–∫ <b>file://</b> ‚Äî IndexedDB –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ.<br>
      –ó–∞–ø—É—Å—Ç–∏: <code>python3 -m http.server 8080</code> ‚Üí –æ—Ç–∫—Ä–æ–π <code>http://localhost:8080/stencil-map.html</code>.
    `;
  }

  // ========= Toast =========
  const toast = document.getElementById('toast');
  let toastTimer = null;
  function showToast(text, ms=1600) {
    toast.textContent = text;
    toast.style.display = 'block';
    if (toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.style.display = 'none', ms);
  }

  // ========= Map =========
  const map = L.map('map').setView([59.9386, 30.3141], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20 }).addTo(map);
  map.getContainer().style.cursor = "grab";
 

  // ========= Projects =========
  const PROJECTS_KEY = "netwings_projects_v1";
  const ACTIVE_PROJECT_KEY = "netwings_active_project_v1";
  const projectSelect = document.getElementById("projectSelect");

  function genId() { return "id_" + Math.random().toString(16).slice(2) + Date.now().toString(16); }

  function loadProjects() {
    let p = [];
    try { p = JSON.parse(localStorage.getItem(PROJECTS_KEY) || "[]"); } catch(e) {}
    if (!p.length) {
      p = [{ id: genId(), name: "–ü—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å" }];
      localStorage.setItem(PROJECTS_KEY, JSON.stringify(p));
      localStorage.setItem(ACTIVE_PROJECT_KEY, p[0].id);
    }
    return p;
  }
  function saveProjects(list) { localStorage.setItem(PROJECTS_KEY, JSON.stringify(list)); }

  let projects = loadProjects();
  let activeProjectId = localStorage.getItem(ACTIVE_PROJECT_KEY) || projects[0].id;

  function renderProjectSelect() {
    projectSelect.innerHTML = "";
    projects.forEach(pr => {
      const opt = document.createElement("option");
      opt.value = pr.id;
      opt.textContent = pr.name;
      projectSelect.appendChild(opt);
    });
    projectSelect.value = activeProjectId;
  }

  function setActiveProject(pid) {
    activeProjectId = pid;
    localStorage.setItem(ACTIVE_PROJECT_KEY, pid);
    unloadAllLayersFromMap();
    zonesGroup.clearLayers();
    loadZones();
    updateGeo();
    loadLayers().then(() => showToast("–ü—Ä–æ–µ–∫—Ç –ø–µ—Ä–µ–∫–ª—é—á—ë–Ω"));
  }

  document.getElementById("projNew").onclick = () => {
    const name = prompt("–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞:", "–ù–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç");
    if (!name) return;
    const pr = { id: genId(), name: name.trim() };
    projects.unshift(pr);
    saveProjects(projects);
    renderProjectSelect();
    setActiveProject(pr.id);
  };
  document.getElementById("projRename").onclick = () => {
    const pr = projects.find(x => x.id === activeProjectId);
    if (!pr) return;
    const name = prompt("–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:", pr.name);
    if (!name) return;
    pr.name = name.trim();
    saveProjects(projects);
    renderProjectSelect();
  };
  document.getElementById("projDelete").onclick = () => {
    if (projects.length <= 1) { alert("–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–æ–µ–∫—Ç."); return; }
    const pr = projects.find(x => x.id === activeProjectId);
    if (!pr) return;
    if (!confirm(`–£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–µ–∫—Ç "${pr.name}"? (–∑–æ–Ω—ã –∏ —Ç—Ä–∞—Ñ–∞—Ä–µ—Ç—ã —Ç–æ–∂–µ —É–¥–∞–ª—è—Ç—Å—è)`)) return;

    try { localStorage.removeItem(zonesKey()); } catch(e) {}
    try { localStorage.removeItem(metaKey()); } catch(e) {}
    try { localStorage.removeItem(activeKey()); } catch(e) {}

    deleteProjectImages(activeProjectId).finally(() => {
      projects = projects.filter(x => x.id !== activeProjectId);
      saveProjects(projects);
      activeProjectId = projects[0].id;
      localStorage.setItem(ACTIVE_PROJECT_KEY, activeProjectId);
      renderProjectSelect();
      setActiveProject(activeProjectId);
    });
  };

  projectSelect.onchange = (e) => setActiveProject(e.target.value);
  renderProjectSelect();

  // ========= Zones =========
  function zonesKey(){ return `netwings_zones_geojson_v5__${activeProjectId}`; }
  const geojsonBox = document.getElementById("geojsonBox");
  const coordInput = document.getElementById("coordInput");
  const btnCheckCoords = document.getElementById("btnCheckCoords");
  const coordResult = document.getElementById("coordResult");

  const ZONES = {
    great:  { label: "1000+/—á",    score: 100, color: "#ff2d2d" },
    normal: { label: "500‚Äì1000/—á", score: 70,  color: "#ff8a00" },
    medium: { label: "100‚Äì500/—á",  score: 40,  color: "#ffd400" },
    low:    { label: "0‚Äì100/—á",    score: 10,  color: "#39c16c" }
  };

  function parseLngLat(raw) {
    const txt = String(raw || "").trim();
    if (!txt) return null;

    const parts = txt.split(/[\s,;]+/).filter(Boolean);
    if (parts.length !== 2) return null;

    const lng = Number(parts[0].replace(",", "."));
    const lat = Number(parts[1].replace(",", "."));
    if (!Number.isFinite(lng) || !Number.isFinite(lat)) return null;
    if (Math.abs(lat) > 90 || Math.abs(lng) > 180) return null;

    return { lng, lat };
  }

  function findZoneByPoint(lat, lng) {
    const point = turf.point([lng, lat]);
    const hits = [];

    zonesGroup.eachLayer((layer) => {
      const gj = layer.toGeoJSON?.();
      if (!gj?.geometry) return;

      const type = gj.geometry.type;
      if (type !== "Polygon" && type !== "MultiPolygon") return;

      const inside = turf.booleanPointInPolygon(point, gj);
      if (!inside) return;

      const zoneType = gj.properties?.zone_type;
      const zone = ZONES[zoneType] || null;
      hits.push({
        score: zone?.score ?? -1,
        zoneLabel: zone?.label || gj.properties?.zone_label || "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
        zoneType: zoneType || "unknown"
      });
    });

    if (!hits.length) return null;
    hits.sort((a, b) => b.score - a.score);
    return hits[0];
  }

  const coordCheckLayer = L.layerGroup().addTo(map);
  let coordCheckMarker = null;

  function showCoordCheckPoint(lat, lng) {
    const latlng = [lat, lng];

    if (!coordCheckMarker) {
      coordCheckMarker = L.circleMarker(latlng, {
        radius: 8,
        color: "#1f6feb",
        weight: 3,
        fillColor: "#7bb6ff",
        fillOpacity: 0.45
      }).addTo(coordCheckLayer);
    } else {
      coordCheckMarker.setLatLng(latlng);
    }

    map.flyTo(latlng, Math.max(map.getZoom(), 16), { duration: 0.5 });
  }

  btnCheckCoords.onclick = () => {
    const parsed = parseLngLat(coordInput.value);
    if (!parsed) {
      coordResult.innerHTML = "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π <b>lng,lat</b>, –Ω–∞–ø—Ä–∏–º–µ—Ä: 30.6228149999999,59.7390690000000";
      return;
    }

    showCoordCheckPoint(parsed.lat, parsed.lng);

    const hit = findZoneByPoint(parsed.lat, parsed.lng);
    if (!hit) {
      coordResult.textContent = `–ù–µ –Ω–∞—à—ë–ª –ø—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å –¥–ª—è —Ç–æ—á–∫–∏ ${parsed.lng.toFixed(6)},${parsed.lat.toFixed(6)}.`;
      return;
    }

    coordResult.textContent = `–ü—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å: ${hit.zoneLabel} (${hit.zoneType}) –¥–ª—è —Ç–æ—á–∫–∏ ${parsed.lng.toFixed(6)},${parsed.lat.toFixed(6)}.`;
  };

  let activeZoneKey = null;
  let selectedZoneLayer = null;

  const zonesGroup = new L.FeatureGroup().addTo(map);
  const editOnly = new L.Control.Draw({ edit: { featureGroup: zonesGroup }, draw: false });
  map.addControl(editOnly);

  function styleForFeature(f) {
    const t = f?.properties?.zone_type || "low";
    const z = ZONES[t] || ZONES.low;
    return { color: z.color, weight: 2, fillColor: z.color, fillOpacity: 0.18 };
  }

  function getLinkedLayers(zoneLayer) {
    const linked = zoneLayer?.__linkedLayers;
    if (!linked) return [];
    return Array.from(linked).filter(Boolean);
  }

  function setLayerSelectedState(layer, selected) {
    if (!layer?.setStyle) return;
    if (!layer.__baseStyle && layer.options) {
      layer.__baseStyle = {
        color: layer.options.color,
        weight: layer.options.weight,
        fillColor: layer.options.fillColor,
        fillOpacity: layer.options.fillOpacity,
        opacity: layer.options.opacity,
        dashArray: layer.options.dashArray
      };
    }

    const base = layer.__baseStyle || {};
    if (!selected) {
      layer.setStyle(base);
      return;
    }

    const weight = Number(base.weight || 2);
    layer.setStyle({
      ...base,
      weight: weight + 2,
      fillOpacity: base.fillOpacity == null ? undefined : Math.min(base.fillOpacity + 0.08, 0.45),
      dashArray: "8 6",
      opacity: 1
    });
    if (layer.bringToFront) layer.bringToFront();
  }

  function clearSelectedZoneLayer() {
    if (!selectedZoneLayer) return;
    setLayerSelectedState(selectedZoneLayer, false);
    getLinkedLayers(selectedZoneLayer).forEach(linked => setLayerSelectedState(linked, false));
    selectedZoneLayer = null;
  }

  function selectZoneLayer(layer) {
    if (!layer) return;
    if (selectedZoneLayer === layer) return;
    clearSelectedZoneLayer();
    selectedZoneLayer = layer;
    setLayerSelectedState(layer, true);
    getLinkedLayers(layer).forEach(linked => setLayerSelectedState(linked, true));
  }

  function removeZoneLayer(layer) {
    if (!layer) return;
    if (selectedZoneLayer === layer) clearSelectedZoneLayer();
    zonesGroup.removeLayer(layer);
    updateGeo();
  }

  function attachDeleteHandlers(layer, ownerLayer = layer) {
    layer.on("remove", () => {
      if (selectedZoneLayer === ownerLayer) clearSelectedZoneLayer();
      if (layer !== ownerLayer && ownerLayer?.__linkedLayers) ownerLayer.__linkedLayers.delete(layer);
    });

    layer.on("click", (e) => {
      if (e?.originalEvent) e.originalEvent.stopPropagation();
      if (!e?.originalEvent?.shiftKey) return;
      if (confirm("–£–¥–∞–ª–∏—Ç—å —ç—Ç—É –∑–æ–Ω—É?")) {
        removeZoneLayer(ownerLayer);
      }
      return;
    });

    layer.on("click", (e) => {
      if (e?.originalEvent) e.originalEvent.stopPropagation();
      if (e?.originalEvent?.shiftKey) return;
      selectZoneLayer(ownerLayer);
    });

    layer.on("contextmenu", (e) => {
      if (e?.originalEvent) { e.originalEvent.preventDefault(); e.originalEvent.stopPropagation(); }
      if (confirm("–£–¥–∞–ª–∏—Ç—å —ç—Ç—É –∑–æ–Ω—É?")) {
        removeZoneLayer(ownerLayer);
      }
    });
  }

  map.on("click", () => { clearSelectedZoneLayer(); });

  function addGeoJsonToZonesGroup(gj) {
    const layer = L.geoJSON(gj, { style: styleForFeature });
    layer.eachLayer(l => {
      attachDeleteHandlers(l);
      zonesGroup.addLayer(l);
      rebuildStreetLineForLayer(l);
    });
  }

  function rebuildStreetLineForLayer(ownerLayer) {
    const sourceLine = ownerLayer?.feature?.properties?.source_line;
    if (!sourceLine?.geometry) return;

    const zoneType = ownerLayer?.feature?.properties?.zone_type;
    const color = (ZONES[zoneType] || ZONES.low).color;

    const lineLayer = L.geoJSON(sourceLine, {
      interactive: true,
      style: { color, weight: 5, opacity: 1 }
    }).addTo(map);

    ownerLayer.__linkedLayers = ownerLayer.__linkedLayers || new Set();
    lineLayer.eachLayer((lineSegment) => {
      ownerLayer.__linkedLayers.add(lineSegment);
      attachDeleteHandlers(lineSegment, ownerLayer);
    });

    ownerLayer.on("remove", () => {
      if (map.hasLayer(lineLayer)) map.removeLayer(lineLayer);
    });
  }

  function updateGeo() {
    const gj = zonesGroup.toGeoJSON();
    geojsonBox.value = JSON.stringify(gj, null, 2);
    try { localStorage.setItem(zonesKey(), JSON.stringify(gj)); } catch(e) {}
  }

  function loadZones() {
    const raw = localStorage.getItem(zonesKey());
    if (!raw) return;
    try { addGeoJsonToZonesGroup(JSON.parse(raw)); } catch(e) {}
  }

  const importFile = document.getElementById("importFile");

  async function buildExportPayload() {
    const mapCenter = map.getCenter();
    const layersExport = await Promise.all(layers.map(async (l) => {
      let dataUrl = l.dataUrl || "";
      if (!dataUrl) dataUrl = await readLayerImage(activeProjectId, l.id) || "";
      return {
        id: l.id,
        name: l.name,
        opacity: l.opacity,
        bounds: l.boundsObj,
        dataUrl: dataUrl || ""
      };
    }));

    return {
      format: "netwings-map-export-v1",
      exportedAt: new Date().toISOString(),
      project: {
        id: activeProjectId,
        name: (projects.find(p => p.id === activeProjectId)?.name) || "–ü—Ä–æ–µ–∫—Ç"
      },
      mapView: {
        center: { lat: mapCenter.lat, lng: mapCenter.lng },
        zoom: map.getZoom()
      },
      zones: zonesGroup.toGeoJSON(),
      layers: layersExport,
      activeLayerId: activeLayerId || null
    };
  }

  function normalizeImportPayload(parsed) {
    if (parsed?.format === "netwings-map-export-v1") return parsed;
    if (parsed?.type === "FeatureCollection") {
      return { format: "legacy-geojson", zones: parsed, layers: [], activeLayerId: null };
    }
    throw new Error("unsupported");
  }

  function parseJsonInput(rawText) {
    const text = (rawText || "").trim();
    if (!text) throw new Error("empty");

    // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ JSON, –≤—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –≤ markdown-–±–ª–æ–∫ ```json ... ```
    const fenced = text.match(/^```(?:json)?\s*([\s\S]*?)\s*```$/i);
    const normalizedText = fenced ? fenced[1].trim() : text;
    return JSON.parse(normalizedText);
  }

  async function applyImportPayload(payload) {
    zonesGroup.clearLayers();
    if (payload?.zones?.type === "FeatureCollection") addGeoJsonToZonesGroup(payload.zones);
    updateGeo();

    unloadAllLayersFromMap();
    await deleteProjectImages(activeProjectId);

    const importedLayers = Array.isArray(payload?.layers) ? payload.layers : [];
    for (const src of importedLayers) {
      if (!src?.dataUrl || !src?.bounds?.sw || !src?.bounds?.ne) continue;
      const id = src.id || genId();
      await persistLayerImage(activeProjectId, id, src.dataUrl);

      const bounds = deserializeBounds(src.bounds);
      const opacity = (typeof src.opacity === "number") ? src.opacity : 0.5;
      const overlay = L.imageOverlay(src.dataUrl, bounds, { opacity, interactive: true }).addTo(map);
      overlay.on("click", () => setActiveLayer(id));

      layers.push({
        id,
        name: src.name || "–¢—Ä–∞—Ñ–∞—Ä–µ—Ç",
        opacity,
        boundsObj: src.bounds,
        overlay,
        dataUrl: src.dataUrl
      });
    }

    const requestedActive = payload?.activeLayerId || "";
    activeLayerId = (requestedActive && getLayer(requestedActive)) ? requestedActive : (layers[0]?.id || null);
    saveMeta();
    renderLayersList();

    const c = payload?.mapView?.center;
    const z = payload?.mapView?.zoom;
    if (c && Number.isFinite(c.lat) && Number.isFinite(c.lng) && Number.isFinite(z)) {
      map.setView([c.lat, c.lng], z);
    }
  }

  document.getElementById("btnExport").onclick = async () => {
    try {
      const payload = await buildExportPayload();
      const text = JSON.stringify(payload, null, 2);

      geojsonBox.value = text;
      localStorage.setItem(zonesKey(), JSON.stringify(payload.zones || { type: "FeatureCollection", features: [] }));

      const blob = new Blob([text], { type: "application/json;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `map-export-${new Date().toISOString().slice(0, 19).replace(/[T:]/g, "-")}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 500);

      showToast("–ö–∞—Ä—Ç–∞ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞ (–∑–æ–Ω—ã + —Å–∫—Ä–∏–Ω—ã + –ø—Ä–∏–≤—è–∑–∫–∞)");
    } catch (e) {
      console.error(e);
      alert("–≠–∫—Å–ø–æ—Ä—Ç –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª. –û—Ç–∫—Ä–æ–π –∫–æ–Ω—Å–æ–ª—å (F12) –∏ –ø—Ä–∏—à–ª–∏ –æ—à–∏–±–∫—É.");
    }
  };

  importFile.onchange = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      geojsonBox.value = text;
      const payload = normalizeImportPayload(JSON.parse(text));
      await applyImportPayload(payload);
      showToast("–ò–º–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à—ë–Ω: –∫–∞—Ä—Ç–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞");
    } catch (err) {
      console.error(err);
      alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª.");
    } finally {
      importFile.value = "";
    }
  };

  document.getElementById("btnImport").onclick = async () => {
    const hasText = !!(geojsonBox.value || "").trim();
    if (!hasText) {
      importFile.click();
      return;
    }
    try {
      const parsed = parseJsonInput(geojsonBox.value);
      const payload = normalizeImportPayload(parsed);
      await applyImportPayload(payload);
      showToast("–ò–º–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à—ë–Ω: –∫–∞—Ä—Ç–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞");
    } catch (e) {
      alert("–ù–µ –º–æ–≥—É –ø—Ä–æ—á–∏—Ç–∞—Ç—å JSON –∏–∑ –ø–æ–ª—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
    }
  };

  // ========= Level buttons =========
  function clearZoneButtonsUI() {
    document.querySelectorAll(".zonebtn").forEach(b => b.classList.remove("active"));
  }
  function toggleZone(zoneKey) {
    if (activeZoneKey === zoneKey) {
      activeZoneKey = null;
      clearZoneButtonsUI();
      refreshState();
      showToast("–£—Ä–æ–≤–µ–Ω—å —Å–Ω—è—Ç");
      if (streetMode) enableStreetDrawing();
      return;
    }
    activeZoneKey = zoneKey;
    clearZoneButtonsUI();
    const btnId = zoneKey === "great" ? "zGreat" :
                  zoneKey === "normal" ? "zNormal" :
                  zoneKey === "medium" ? "zMedium" : "zLow";
    document.getElementById(btnId).classList.add("active");
    refreshState();
    showToast(`–£—Ä–æ–≤–µ–Ω—å: ${ZONES[zoneKey].label}`);
    if (streetMode) enableStreetDrawing();
  }
  document.getElementById("zGreat").onclick  = () => toggleZone("great");
  document.getElementById("zNormal").onclick = () => toggleZone("normal");
  document.getElementById("zMedium").onclick = () => toggleZone("medium");
  document.getElementById("zLow").onclick    = () => toggleZone("low");

  // ========= Street mode =========
  const stateLine = document.getElementById("stateLine");
  const streetWidthEl = document.getElementById("streetWidth");
  const btnStreetMode = document.getElementById("btnStreetMode");

  let streetMode = false;
  let streetDrawer = null;

  let isCalibrating = false;

  function refreshState() {
    const lvl = activeZoneKey ? ZONES[activeZoneKey].label : "–Ω–µ –≤—ã–±—Ä–∞–Ω";
    if (!streetMode) stateLine.textContent = `–≤—ã–∫–ª—é—á–µ–Ω–æ ‚Ä¢ —É—Ä–æ–≤–µ–Ω—å: ${lvl}`;
    else stateLine.textContent = `–ª–∏–Ω–∏–∏ –≤–∫–ª—é—á–µ–Ω—ã ‚Ä¢ –¥–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω—è—è –∑–æ–Ω–∞ ‚Ä¢ —É—Ä–æ–≤–µ–Ω—å: ${lvl}`;
  }

  function parseStreetWidthMeters() {
    const w = Number(String(streetWidthEl.value || "15").trim().replace(",", "."));
    if (!Number.isFinite(w)) return 15;
    return Math.max(2, Math.min(60, w));
  }

  function disableStreetDrawing() { try { if (streetDrawer) streetDrawer.disable(); } catch(e) {} }

  function syncMapCursor() {
    const mapEl = map.getContainer();
    if (!mapEl) return;
    mapEl.style.cursor = streetMode ? "crosshair" : "grab";
  }

  function enableStreetDrawing() {
    disableStreetDrawing();
    if (!streetMode) return;
    if (isCalibrating) return;
    if (!activeZoneKey) { showToast("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —É—Ä–æ–≤–µ–Ω—å üî¥üü†üü°üü¢", 1800); return; }
    if (!streetDrawer) streetDrawer = new L.Draw.Polyline(map, { shapeOptions: {} });
    try { streetDrawer.enable(); } catch(e) {}
    syncMapCursor();
  }

  btnStreetMode.onclick = () => {
    streetMode = !streetMode;
    if (streetMode) {
      btnStreetMode.textContent = "üü© –õ–∏–Ω–∏–∏ –≤–∫–ª—é—á–µ–Ω—ã (—Ä–∏—Å—É–π)";
      enableStreetDrawing();
      showToast("–†–∏—Å—É–π –ª–∏–Ω–∏—é ‚Äî —Å–æ–∑–¥–∞—Å—Ç—Å—è –ø–æ–ª–æ—Å–∞ —Ñ–∞—Å–∞–¥–∞", 1800);
    } else {
      btnStreetMode.textContent = "üñä –í–∫–ª—é—á–∏—Ç—å –ª–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞";
      disableStreetDrawing();
      showToast("–õ–∏–Ω–∏–∏ –≤—ã–∫–ª—é—á–µ–Ω—ã");
    }
    syncMapCursor();
    refreshState();
  };

  function getLongestLineCoords(feature) {
    if (!feature?.geometry) throw new Error("OFFSET_EMPTY_GEOMETRY");
    const { type, coordinates } = feature.geometry;

    if (type === "LineString") return coordinates;

    if (type === "MultiLineString") {
      if (!Array.isArray(coordinates) || !coordinates.length) throw new Error("OFFSET_EMPTY_GEOMETRY");

      let longest = null;
      let longestLen = -1;
      for (const part of coordinates) {
        if (!Array.isArray(part) || part.length < 2) continue;
        const len = turf.length(turf.lineString(part), { units: "kilometers" });
        if (len > longestLen) {
          longestLen = len;
          longest = part;
        }
      }
      if (longest) return longest;
    }

    throw new Error("OFFSET_TOO_COMPLEX");
  }

  function makeCorridorPolygonFromOffsets(lineFeature, widthMeters) {
    const halfWidthKm = (widthMeters / 2) / 1000;
    const leftOffset = turf.lineOffset(lineFeature, +halfWidthKm, { units: "kilometers" });
    const rightOffset = turf.lineOffset(lineFeature, -halfWidthKm, { units: "kilometers" });

    const leftCoords = getLongestLineCoords(leftOffset);
    const rightCoords = getLongestLineCoords(rightOffset);

    if (leftCoords.length < 2 || rightCoords.length < 2) throw new Error("OFFSET_TOO_SHORT");

    const ring = [...leftCoords, ...[...rightCoords].reverse()];
    const first = ring[0];
    const last = ring[ring.length - 1];

    if (!first || !last) throw new Error("OFFSET_EMPTY_GEOMETRY");
    if (first[0] !== last[0] || first[1] !== last[1]) ring.push([...first]);
    if (ring.length < 4) throw new Error("OFFSET_TOO_SHORT");

    return turf.polygon([ring]);
  }

  function makeProps(zoneKey, widthMeters) {
    const z = ZONES[zoneKey];
    return {
      zone_type: zoneKey,
      zone_label: z.label,
      zone_score: z.score,
      mode: "street_facade_corridor",
      facade_width_m: widthMeters
    };
  }

  map.on(L.Draw.Event.CREATED, (event) => {
    if (!streetMode) return;
    if (!activeZoneKey) { try { event.layer.remove(); } catch(_) {} return; }

    const w = parseStreetWidthMeters();
    const z = ZONES[activeZoneKey];

    const line = event.layer.toGeoJSON();
    let poly;
    try { poly = makeCorridorPolygonFromOffsets(line, w); }
    catch (e) {
      const msg = e?.message === "OFFSET_TOO_COMPLEX"
        ? "–°–ª–∏—à–∫–æ–º —Å–ª–æ–∂–Ω–∞—è –ª–∏–Ω–∏—è, –Ω–∞—Ä–∏—Å—É–π —á—É—Ç—å –ø—Ä–æ—â–µ"
        : "–ù–µ —Å–º–æ–≥ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –ø–æ–ª–æ—Å—É. –ù–∞—Ä–∏—Å—É–π –ª–∏–Ω–∏—é —á—É—Ç—å –¥–ª–∏–Ω–Ω–µ–µ.";
      showToast(msg, 2200);
      return;
    }

    const polyLayer = L.geoJSON(poly, {
      style: { color: z.color, weight: 2, fillColor: z.color, fillOpacity: 0.18 }
    });

    polyLayer.eachLayer(l => {
      l.feature = l.feature || { type:"Feature", properties:{}, geometry:null };
      Object.assign(l.feature.properties, makeProps(activeZoneKey, w));
      l.feature.properties.source_line = line;
      attachDeleteHandlers(l);
      zonesGroup.addLayer(l);
      rebuildStreetLineForLayer(l);
    });

    updateGeo();
    setTimeout(() => { if (streetMode) enableStreetDrawing(); }, 0);
  });

  // ESC
  window.addEventListener("keydown", (ev) => {
    const targetTag = (ev.target?.tagName || "").toUpperCase();
    const typingTarget = ev.target?.isContentEditable || ["INPUT", "TEXTAREA", "SELECT"].includes(targetTag);

    if (!typingTarget && (ev.key === "Delete" || ev.key === "Backspace") && selectedZoneLayer) {
      ev.preventDefault();
      if (confirm("–£–¥–∞–ª–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—É—é –∑–æ–Ω—É?")) removeZoneLayer(selectedZoneLayer);
      return;
    }

    if (ev.key === "Escape") {
      ev.preventDefault();
      clearSelectedZoneLayer();
      streetMode = false;
      btnStreetMode.textContent = "üñä –í–∫–ª—é—á–∏—Ç—å –ª–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞";
      disableStreetDrawing();
      syncMapCursor();
      refreshState();
      stopCalibrate();
      closeCalModal();
      showToast("–í—ã–∫–ª—é—á–µ–Ω–æ (Esc)");
    }
  }, { passive:false });

  // ========= IndexedDB (images) =========
  const DB_NAME = "netwings_stencil_db_v4";
  const DB_STORE = "layers";
  const LAYER_FALLBACK_PREFIX = "netwings_stencil_layer_data_v1__";
  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE, { keyPath: "key" });
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function layerKey(projectId, layerId){ return `${projectId}:${layerId}`; }
  function layerFallbackKey(projectId, layerId){ return `${LAYER_FALLBACK_PREFIX}${projectId}__${layerId}`; }

  function saveLayerFallback(projectId, layerId, dataUrl) {
    try {
      localStorage.setItem(layerFallbackKey(projectId, layerId), dataUrl);
      return true;
    } catch (_) {
      return false;
    }
  }
  function loadLayerFallback(projectId, layerId) {
    try { return localStorage.getItem(layerFallbackKey(projectId, layerId)) || null; } catch (_) { return null; }
  }
  function deleteLayerFallback(projectId, layerId) {
    try { localStorage.removeItem(layerFallbackKey(projectId, layerId)); } catch (_) {}
  }
  function deleteProjectFallbacks(projectId) {
    const prefix = `${LAYER_FALLBACK_PREFIX}${projectId}__`;
    const keys = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i) || "";
      if (key.startsWith(prefix)) keys.push(key);
    }
    keys.forEach((key) => {
      try { localStorage.removeItem(key); } catch (_) {}
    });
  }

  async function idbPutLayer(projectId, layerId, dataUrl) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).put({ key: layerKey(projectId, layerId), projectId, layerId, dataUrl });
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }
  async function idbGetLayer(projectId, layerId) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).get(layerKey(projectId, layerId));
      req.onsuccess = () => resolve(req.result?.dataUrl || null);
      req.onerror = () => reject(req.error);
    });
  }
  async function idbDeleteLayer(projectId, layerId) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).delete(layerKey(projectId, layerId));
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }

  async function persistLayerImage(projectId, layerId, dataUrl) {
    try {
      await idbPutLayer(projectId, layerId, dataUrl);
      deleteLayerFallback(projectId, layerId);
      return "idb";
    } catch (_) {
      const saved = saveLayerFallback(projectId, layerId, dataUrl);
      return saved ? "fallback" : "none";
    }
  }
  async function readLayerImage(projectId, layerId) {
    try {
      const idbData = await idbGetLayer(projectId, layerId);
      if (idbData) return idbData;
    } catch (_) {}
    return loadLayerFallback(projectId, layerId);
  }
  async function deleteLayerImage(projectId, layerId) {
    try { await idbDeleteLayer(projectId, layerId); } catch (_) {}
    deleteLayerFallback(projectId, layerId);
  }

  async function deleteProjectImages(projectId) {
    try {
      const db = await openDB();
      await new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, "readwrite");
        const store = tx.objectStore(DB_STORE);
        const req = store.openCursor();
        req.onsuccess = () => {
          const cursor = req.result;
          if (!cursor) return;
          const v = cursor.value;
          if (v?.projectId === projectId) cursor.delete();
          cursor.continue();
        };
        tx.oncomplete = () => resolve(true);
        tx.onerror = () => reject(tx.error);
      });
    } catch (_) {}
    deleteProjectFallbacks(projectId);
    return true;
  }

  // ========= Layers =========
  function metaKey(){ return `netwings_stencil_layers_meta_v4__${activeProjectId}`; }
  function activeKey(){ return `netwings_stencil_layers_active_v4__${activeProjectId}`; }

  const layersList = document.getElementById("layersList");
  const btnAddLayers = document.getElementById("btnAddLayers");
  const imgFiles = document.getElementById("imgFiles");

  let layers = [];
  let activeLayerId = null;

  function fileToDataURL(file) {
    return new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onerror = () => reject(new Error("FileReader error"));
      r.onload  = () => resolve(r.result);
      r.readAsDataURL(file);
    });
  }

  function serializeBounds(bounds) {
    const sw = bounds.getSouthWest();
    const ne = bounds.getNorthEast();
    return { sw: {lat: sw.lat, lng: sw.lng}, ne: {lat: ne.lat, lng: ne.lng} };
  }
  function deserializeBounds(obj) {
    return L.latLngBounds([obj.sw.lat, obj.sw.lng], [obj.ne.lat, obj.ne.lng]);
  }

  function saveMeta() {
    const payload = layers.map(l => ({
      id: l.id,
      name: l.name,
      opacity: l.opacity,
      bounds: l.boundsObj
    }));
    localStorage.setItem(metaKey(), JSON.stringify(payload));
    localStorage.setItem(activeKey(), activeLayerId || "");
  }

  function getLayer(id) { return layers.find(x => x.id === id) || null; }

  function setActiveLayer(id) {
    activeLayerId = id;
    layers.forEach(l => l.overlay.setZIndex(l.id === activeLayerId ? 1000 : 500));
    renderLayersList();
    saveMeta();
  }

  function updateOpacity(id, opacity01) {
    const l = getLayer(id);
    if (!l) return;
    l.opacity = opacity01;
    l.overlay.setOpacity(opacity01);
    saveMeta();
  }

  async function deleteLayer(id) {
    const idx = layers.findIndex(x => x.id === id);
    if (idx < 0) return;
    const l = layers[idx];
    map.removeLayer(l.overlay);
    layers.splice(idx, 1);
    await deleteLayerImage(activeProjectId, id);
    if (activeLayerId === id) activeLayerId = layers.length ? layers[0].id : null;
    saveMeta();
    renderLayersList();
  }

  function renderLayersList() {
    layersList.innerHTML = "";
    if (!layers.length) {
      layersList.innerHTML = `<div class="small">–¢—Ä–∞—Ñ–∞—Ä–µ—Ç–æ–≤ –Ω–µ—Ç. –ù–∞–∂–º–∏ ‚Äú–î–æ–±–∞–≤–∏—Ç—å —Å–∫—Ä–∏–Ω(—ã)‚Äù.</div>`;
      return;
    }

    layers.forEach(l => {
      const isActive = l.id === activeLayerId;

      const item = document.createElement("div");
      item.className = "layerItem" + (isActive ? " active" : "");
      item.onclick = () => setActiveLayer(l.id);

      const top = document.createElement("div");
      top.className = "layerTop";

      const name = document.createElement("div");
      name.className = "layerName";
      name.textContent = l.name || "–¢—Ä–∞—Ñ–∞—Ä–µ—Ç";

      const pill = document.createElement("div");
      pill.className = "pill";
      pill.textContent = "–¢–æ–ª—å–∫–æ –ø—Ä–∏–≤—è–∑–∫–∞";

      top.appendChild(name);
      top.appendChild(pill);

      const btnRow = document.createElement("div");
      btnRow.className = "row";

      const bCal = document.createElement("button");
      bCal.className = "mini primary";
      bCal.textContent = "üéØ –ü—Ä–∏–≤—è–∑–∫–∞ (2 —Ç–æ—á–∫–∏)";
      bCal.onclick = (e) => { e.stopPropagation(); if (!isActive) setActiveLayer(l.id); startCalibrate(l.id); };

      const bDel = document.createElement("button");
      bDel.className = "mini danger";
      bDel.textContent = "–£–¥–∞–ª–∏—Ç—å";
      bDel.onclick = (e) => { e.stopPropagation(); deleteLayer(l.id); };

      btnRow.appendChild(bCal);
      btnRow.appendChild(bDel);

      const opacityWrap = document.createElement("div");
      opacityWrap.innerHTML = `<div class="small">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å</div>`;
      const range = document.createElement("input");
      range.type = "range";
      range.min = "0";
      range.max = "100";
      range.value = String(Math.round((l.opacity ?? 0.5) * 100));
      range.oninput = (e) => { e.stopPropagation(); updateOpacity(l.id, Number(e.target.value)/100); };
      opacityWrap.appendChild(range);

      const renameWrap = document.createElement("div");
      renameWrap.innerHTML = `<div class="small" style="margin-top:8px">–ù–∞–∑–≤–∞–Ω–∏–µ</div>`;
      const rename = document.createElement("input");
      rename.type = "text";
      rename.value = l.name || "";
      rename.placeholder = "–Ω–∞–ø—Ä–∏–º–µ—Ä: –¢—Ä–∞—Ñ–∞—Ä–µ—Ç —Ç—Ä–∞—Ñ–∏–∫–∞";
      rename.oninput = (e) => { e.stopPropagation(); l.name = e.target.value; saveMeta(); };
      renameWrap.appendChild(rename);

      item.appendChild(top);
      item.appendChild(btnRow);
      item.appendChild(opacityWrap);
      item.appendChild(renameWrap);

      layersList.appendChild(item);
    });
  }

  async function addLayerFromDataUrl(dataUrl) {
    const id = genId();
    const bounds = map.getBounds();
    const savedMode = await persistLayerImage(activeProjectId, id, dataUrl);

    const overlay = L.imageOverlay(dataUrl, bounds, { opacity: 0.5, interactive: true }).addTo(map);
    overlay.on("click", () => setActiveLayer(id));

    const layerObj = { id, name: "–¢—Ä–∞—Ñ–∞—Ä–µ—Ç", opacity: 0.5, boundsObj: serializeBounds(bounds), overlay, dataUrl };
    layers.unshift(layerObj);
    activeLayerId = id;
    saveMeta();
    renderLayersList();
    if (savedMode === "none") {
      showToast("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–∫—Ä–∏–Ω –ª–æ–∫–∞–ª—å–Ω–æ: –ø—Ä–æ–≤–µ—Ä—å —Ä–µ–∂–∏–º –±—Ä–∞—É–∑–µ—Ä–∞/–∫–≤–æ—Ç—É", 2600);
      return;
    }
    if (savedMode === "fallback") {
      showToast("–°–∫—Ä–∏–Ω —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ localStorage (—Ä–µ–∑–µ—Ä–≤), IndexedDB –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", 2600);
      return;
    }
    showToast("–¢—Ä–∞—Ñ–∞—Ä–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω ‚Üí —Å–¥–µ–ª–∞–π –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å ‚Üí –ø—Ä–∏–≤—è–∂–∏ –ø–æ 2 —Ç–æ—á–∫–∞–º", 2200);
  }

  function unloadAllLayersFromMap() {
    try { layers.forEach(l => { try { map.removeLayer(l.overlay); } catch(_) {} }); } catch(_) {}
    layers = [];
    activeLayerId = null;
    renderLayersList();
  }

  async function loadLayers() {
    const rawMeta = localStorage.getItem(metaKey());
    let meta = [];
    try { meta = rawMeta ? (JSON.parse(rawMeta) || []) : []; } catch(e) { meta = []; }

    layers = [];
    for (const m of meta) {
      let dataUrl = m.dataUrl || null;
      if (!dataUrl) dataUrl = await readLayerImage(activeProjectId, m.id);
      if (!dataUrl) continue;

      const bounds = deserializeBounds(m.bounds);
      const overlay = L.imageOverlay(dataUrl, bounds, {
        opacity: typeof m.opacity === "number" ? m.opacity : 0.5,
        interactive: true
      }).addTo(map);
      overlay.on("click", () => setActiveLayer(m.id));

      layers.push({
        id: m.id,
        name: m.name || "–¢—Ä–∞—Ñ–∞—Ä–µ—Ç",
        opacity: typeof m.opacity === "number" ? m.opacity : 0.5,
        boundsObj: m.bounds,
        overlay,
        dataUrl
      });
    }

    const savedActive = localStorage.getItem(activeKey()) || "";
    activeLayerId = (savedActive && getLayer(savedActive)) ? savedActive : (layers[0]?.id || null);
    renderLayersList();
    syncMapCursor();
  }

  btnAddLayers.onclick = () => { imgFiles.value = ""; imgFiles.click(); };
  imgFiles.onchange = async (e) => {
    const files = Array.from(e.target.files || []);
    if (!files.length) return;
    for (const f of files) {
      const dataUrl = await fileToDataURL(f);
      await addLayerFromDataUrl(dataUrl);
    }
  };

  // ========= Calibration modal =========
  const calModal = document.getElementById("calModal");
  const calHint = document.getElementById("calHint");
  const calImg = document.getElementById("calImg");
  const calViewport = document.getElementById("calViewport");
  const calStage = document.getElementById("calStage");

  const calZoomIn = document.getElementById("calZoomIn");
  const calZoomOut = document.getElementById("calZoomOut");
  const calZoomFit = document.getElementById("calZoomFit");

  const markA = document.getElementById("markA");
  const markB = document.getElementById("markB");

  function metersToLat(m) { return m / 111320; }
  function metersToLng(m, atLat) { return m / (111320 * Math.cos(atLat * Math.PI/180)); }

  let calZoom = 1, calPanX = 0, calPanY = 0;
  let calMinZoom = 1, calMaxZoom = 12;

  function applyCalTransform() {
    calImg.style.transform = `translate(${calPanX}px, ${calPanY}px) scale(${calZoom})`;
    // –º–∞—Ä–∫–µ—Ä—ã –¥–æ–ª–∂–Ω—ã –¥–≤–∏–≥–∞—Ç—å—Å—è –≤–º–µ—Å—Ç–µ —Å –∫–∞—Ä—Ç–∏–Ω–∫–æ–π, –ø–æ—ç—Ç–æ–º—É —Å—Ç–∞–≤–∏–º –∏—Ö –≤ "—ç–∫—Ä–∞–Ω–Ω—ã—Ö" –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö –Ω–∏–∂–µ (setScreenMarker)
  }

  function getFitZoom() {
    const vw = calViewport.clientWidth;
    const vh = calViewport.clientHeight;
    const iw = calImg.naturalWidth || 1;
    const ih = calImg.naturalHeight || 1;
    return Math.max(vw / iw, vh / ih);
  }

  function clampPan() {
    const vw = calViewport.clientWidth;
    const vh = calViewport.clientHeight;
    const iw = (calImg.naturalWidth || 1) * calZoom;
    const ih = (calImg.naturalHeight || 1) * calZoom;

    const minX = vw - iw;
    const minY = vh - ih;

    calPanX = Math.min(0, Math.max(minX, calPanX));
    calPanY = Math.min(0, Math.max(minY, calPanY));
  }

  function setZoom(newZoom, anchorX, anchorY) {
    const prevZoom = calZoom;
    calZoom = Math.max(calMinZoom, Math.min(calMaxZoom, newZoom));
    const k = calZoom / prevZoom;
    calPanX = anchorX - (anchorX - calPanX) * k;
    calPanY = anchorY - (anchorY - calPanY) * k;
    clampPan();
    applyCalTransform();
    refreshMarkers();
  }

  function fitAndCenter() {
    calMinZoom = getFitZoom();
    calZoom = calMinZoom;

    const vw = calViewport.clientWidth;
    const vh = calViewport.clientHeight;
    const iw = (calImg.naturalWidth || 1) * calZoom;
    const ih = (calImg.naturalHeight || 1) * calZoom;

    calPanX = (vw - iw) / 2;
    calPanY = (vh - ih) / 2;
    clampPan();
    applyCalTransform();
    refreshMarkers();
  }

  function openCalModal(text) {
    calHint.innerHTML = text;
    calModal.style.display = "block";
  }
  function closeCalModal() { calModal.style.display = "none"; }
  document.getElementById("calClose").onclick = () => { stopCalibrate(); closeCalModal(); };

  calZoomIn.onclick = () => setZoom(calZoom * 1.15, calViewport.clientWidth/2, calViewport.clientHeight/2);
  calZoomOut.onclick = () => setZoom(calZoom / 1.15, calViewport.clientWidth/2, calViewport.clientHeight/2);
  calZoomFit.onclick = () => fitAndCenter();

  calViewport.addEventListener("wheel", (e) => {
    if (calModal.style.display !== "block") return;
    e.preventDefault();
    const rect = calViewport.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const factor = e.deltaY < 0 ? 1.12 : 1/1.12;
    setZoom(calZoom * factor, cx, cy);
  }, { passive:false });

  // --- New pointer logic (fix for Mac trackpad): click is detected on pointerup if moved <= 8px
  let panPointerId = null;
  let panStart = null;
  const CLICK_TOLERANCE_PX = 8;

  function viewportPointFromClient(clientX, clientY) {
    const rect = calViewport.getBoundingClientRect();
    return { vx: clientX - rect.left, vy: clientY - rect.top };
  }

  function imgPointFromViewport(vx, vy) {
    const x = (vx - calPanX) / calZoom;
    const y = (vy - calPanY) / calZoom;
    return { x, y };
  }

  function setMarker(el, pxPoint, labelVisible) {
    if (!pxPoint) { el.style.display = "none"; return; }
    // –ø–µ—Ä–µ–≤–æ–¥–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–∞—Ä—Ç–∏–Ω–∫–∏ -> –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã viewport (—ç–∫—Ä–∞–Ω)
    const vx = pxPoint.x * calZoom + calPanX;
    const vy = pxPoint.y * calZoom + calPanY;
    el.style.left = `${vx}px`;
    el.style.top  = `${vy}px`;
    el.style.display = "block";
  }

  function refreshMarkers() {
    setMarker(markA, calState.imgA, true);
    setMarker(markB, calState.imgB, true);
  }

  function tryHandleScreenClick(clientX, clientY) {
    const { vx, vy } = viewportPointFromClient(clientX, clientY);
    const p = imgPointFromViewport(vx, vy);

    if (p.x < 0 || p.y < 0 || p.x > calImg.naturalWidth || p.y > calImg.naturalHeight) {
      showToast("–ö–ª–∏–∫–Ω–∏ –ø–æ —Å–∞–º–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–µ", 1200);
      return;
    }

    if (!calState.active) return;

    if (calState.step === 2) {
      calState.imgA = { x: p.x, y: p.y };
      refreshMarkers();
      calState.step = 3;
      closeCalModal();
      showToast("–®–∞–≥ 3/4: –∫–ª–∏–∫–Ω–∏ –¢–û–ß–ö–£ B –Ω–∞ –ö–ê–†–¢–ï", 2200);
      return;
    }

    if (calState.step === 4) {
      calState.imgB = { x: p.x, y: p.y };
      refreshMarkers();
      closeCalModal();
      applyCalibration();
      stopCalibrate();
      return;
    }
  }

  calStage.addEventListener("pointerdown", (e) => {
    if (calModal.style.display !== "block") return;
    panPointerId = e.pointerId;
    calStage.setPointerCapture(panPointerId);
    calStage.style.cursor = "grabbing";

    panStart = {
      x: e.clientX, y: e.clientY,
      panX: calPanX, panY: calPanY
    };
  });

  calStage.addEventListener("pointermove", (e) => {
    if (panPointerId === null || e.pointerId !== panPointerId) return;
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    calPanX = panStart.panX + dx;
    calPanY = panStart.panY + dy;
    clampPan();
    applyCalTransform();
    refreshMarkers();
  });

  calStage.addEventListener("pointerup", (e) => {
    if (panPointerId === null || e.pointerId !== panPointerId) return;

    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;

    calStage.style.cursor = "grab";
    try { calStage.releasePointerCapture(panPointerId); } catch(_) {}
    panPointerId = null;

    // –µ—Å–ª–∏ –ø–æ—á—Ç–∏ –Ω–µ –¥–≤–∏–≥–∞–ª–∏ ‚Äî —ç—Ç–æ –∫–ª–∏–∫
    if (Math.hypot(dx, dy) <= CLICK_TOLERANCE_PX) {
      tryHandleScreenClick(e.clientX, e.clientY);
    }
  });

  // ========= Calibration state =========
  const calState = {
    active: false,
    layerId: null,
    step: 0, // 1 mapA, 2 imgA, 3 mapB, 4 imgB
    mapA: null,
    mapB: null,
    imgA: null,
    imgB: null
  };

  function startCalibrate(layerId) {
    const l = getLayer(layerId);
    if (!l) return;
    setActiveLayer(layerId);

    isCalibrating = true;
    disableStreetDrawing();

    calState.active = true;
    calState.layerId = layerId;
    calState.step = 1;
    calState.mapA = calState.mapB = null;
    calState.imgA = calState.imgB = null;
    refreshMarkers();

    closeCalModal();
    showToast("–ü—Ä–∏–≤—è–∑–∫–∞: –∫–ª–∏–∫–Ω–∏ —Ç–æ—á–∫—É A –Ω–∞ –ö–ê–†–¢–ï", 2200);
  }

  function stopCalibrate() {
    calState.active = false;
    calState.layerId = null;
    calState.step = 0;
    calState.mapA = calState.mapB = null;
    calState.imgA = calState.imgB = null;
    refreshMarkers();

    isCalibrating = false;
    if (streetMode) enableStreetDrawing();
  }

  function mapDistanceMeters(a, b) {
    const km = turf.distance(turf.point([a.lng, a.lat]), turf.point([b.lng, b.lat]), { units:"kilometers" });
    return km * 1000;
  }
  function pixelDistance(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function applyCalibration() {
    const l = getLayer(calState.layerId);
    if (!l) return;

    const mA = calState.mapA, mB = calState.mapB;
    const pA = calState.imgA, pB = calState.imgB;

    const dM = mapDistanceMeters(mA, mB);
    const dP = pixelDistance(pA, pB);
    if (!dP || dP < 2) { alert("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏ –Ω–∞ —Å–∫—Ä–∏–Ω–µ."); return; }

    const metersPerPixel = dM / dP;
    const W = calImg.naturalWidth;
    const H = calImg.naturalHeight;

    function pxToLatLng(dxPx, dyPx) {
      const dxM = dxPx * metersPerPixel;
      const dyM = dyPx * metersPerPixel;
      const dLat = -metersToLat(dyM);
      const dLng = metersToLng(dxM, mA.lat);
      return { lat: mA.lat + dLat, lng: mA.lng + dLng };
    }

    const tl = pxToLatLng(0 - pA.x, 0 - pA.y);
    const tr = pxToLatLng(W - pA.x, 0 - pA.y);
    const bl = pxToLatLng(0 - pA.x, H - pA.y);
    const br = pxToLatLng(W - pA.x, H - pA.y);

    const minLat = Math.min(tl.lat, tr.lat, bl.lat, br.lat);
    const maxLat = Math.max(tl.lat, tr.lat, bl.lat, br.lat);
    const minLng = Math.min(tl.lng, tr.lng, bl.lng, br.lng);
    const maxLng = Math.max(tl.lng, tr.lng, bl.lng, br.lng);

    const bounds = L.latLngBounds([minLat, minLng], [maxLat, maxLng]);
    l.overlay.setBounds(bounds);
    l.boundsObj = serializeBounds(bounds);
    saveMeta();

    showToast("–ü—Ä–∏–≤—è–∑–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∞ ‚úÖ", 2000);
  }

  // Map clicks for calibration
  map.on("click", (e) => {
    if (!calState.active) return;

    if (calState.step === 1) {
      calState.mapA = e.latlng;
      calState.step = 2;

      const l = getLayer(calState.layerId);
      calImg.src = l.dataUrl;
      calImg.onload = () => {
        openCalModal("–®–∞–≥ 2/4: –∫–ª–∏–∫–Ω–∏ –¢–û–ß–ö–£ A –Ω–∞ –°–ö–†–ò–ù–ï (–º–æ–∂–Ω–æ –ø—Ä–∏–±–ª–∏–∂–∞—Ç—å/–ø–∞–Ω–∏—Ç—å).");
        fitAndCenter();
        refreshMarkers();
      };
      return;
    }

    if (calState.step === 3) {
      calState.mapB = e.latlng;
      calState.step = 4;

      const l = getLayer(calState.layerId);
      calImg.src = l.dataUrl;
      calImg.onload = () => {
        openCalModal("–®–∞–≥ 4/4: –∫–ª–∏–∫–Ω–∏ –¢–û–ß–ö–£ B –Ω–∞ –°–ö–†–ò–ù–ï (–ø–æ—Å–ª–µ –∫–ª–∏–∫–∞ –ø—Ä–∏–≤—è–∑–∫–∞ –ø—Ä–∏–º–µ–Ω–∏—Ç—Å—è).");
        fitAndCenter();
        refreshMarkers();
      };
      return;
    }
  });

  // ========= Init =========
  loadZones();
  updateGeo();
  syncSideUI();
  refreshState();

  loadLayers().then(() => {
    showToast("–ì–æ—Ç–æ–≤–æ. –ü—Ä–æ–µ–∫—Ç ‚Üí —Ç—Ä–∞—Ñ–∞—Ä–µ—Ç ‚Üí –ø—Ä–∏–≤—è–∑–∫–∞ ‚Üí –ª–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞.", 2400);
  });
</script>

</body>
</html>
