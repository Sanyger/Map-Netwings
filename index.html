<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NEtwings ‚Äî –¢—Ä–∞—Ñ–∞—Ä–µ—Ç + –ø—Ä–æ–µ–∫—Ç—ã + –ø—Ä–∏–≤—è–∑–∫–∞ (2 —Ç–æ—á–∫–∏) + –ª–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>

  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #app { height: 100%; display: grid; grid-template-columns: 520px 1fr; }
    #sidebar { padding: 14px; overflow: auto; border-right: 1px solid #e5e5e5; background: #fff; }
    #map { height: 100%; }

    h1 { font-size: 18px; margin: 0 0 10px; font-weight: 900; }
    .muted { color:#666; font-size: 12px; line-height: 1.35; }

    .card { border:1px solid #eee; border-radius: 12px; padding: 12px; margin: 12px 0; background:#fafafa; }
    .label { font-weight: 900; margin: 0 0 8px; font-size: 13px; }
    .small { font-size: 12px; color:#666; line-height: 1.35; }

    .btn { padding: 10px 12px; border:1px solid #ddd; border-radius: 10px; background:#fff; cursor:pointer; font-weight: 800; font-size: 13px; width: 100%; text-align:left; }
    .btn.primary { border-color:#2f6fed; color:#2f6fed; }
    .btn + .btn { margin-top: 8px; }

    input[type="range"] { width:100%; }
    input[type="text"], select { width:100%; padding:10px; border:1px solid #ddd; border-radius:10px; font-size:13px; background:#fff; }
    textarea { width:100%; height: 150px; border:1px solid #ddd; border-radius:10px; padding:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px; }

    #layersList { max-height: 320px; overflow-y: auto; padding-right: 6px; }

    .layerItem { background:#fff; border: 1px solid #e8e8e8; border-radius: 12px; padding: 10px; margin-bottom: 10px; cursor: pointer; transition: 0.15s; }
    .layerItem:hover { border-color:#cfcfcf; }
    .layerItem.active { border: 2px solid #ff7a00; background: #fff5ea; }
    .layerTop { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 8px; }
    .layerName { font-weight: 900; font-size: 13px; }
    .pill { font-size: 11px; padding: 4px 8px; border-radius: 999px; border:1px solid #ddd; background:#fafafa; color:#555; white-space: nowrap; }

    .row { display:flex; gap: 8px; flex-wrap: wrap; }
    .mini { padding: 8px 10px; border-radius: 10px; border:2px solid #ddd; background:#fff; cursor:pointer; font-weight: 900; font-size: 12px; flex: 1 1 auto; text-align: center; }
    .mini.primary { border-color:#2f6fed; color:#2f6fed; }
    .mini.danger { border-color:#e5484d; color:#e5484d; }
    .mini.ok { border-color:#1a7f37; color:#1a7f37; }
    .mini.active { outline: 2px solid #111; }

    .zones { display:flex; gap:8px; flex-wrap: wrap; }
    .zonebtn { flex:1 1 46%; border-radius: 10px; padding: 10px; border:2px solid #ddd; cursor:pointer; font-weight: 900; background:#fff; }
    .zonebtn.active { outline: 2px solid #111; }

    .toast { position: fixed; left: 12px; bottom: 12px; z-index: 999999; background: rgba(20,20,20,0.92); color: #fff;
      padding: 10px 12px; border-radius: 12px; font-size: 12px; display:none; max-width: 680px; }

    .warn { background:#fff2f2; border:1px solid #ffd1d1; color:#8a1f1f; padding:10px; border-radius:10px; font-size:12px; margin-top:10px; display:none; }

    /* Calibration modal */
    #calModal { display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:999999; }
    #calBox { max-width:1100px; margin:18px auto; background:#fff; border-radius:14px; padding:14px; }
    .calTop { display:flex; justify-content:space-between; gap:10px; align-items:center; }
    #calViewport { margin-top:10px; border:1px solid #eee; border-radius:12px; overflow:hidden; height:74vh; background:#f7f7f7; }
    #calStage { width:100%; height:100%; position:relative; touch-action:none; cursor:grab; }
    #calImg { position:absolute; left:0; top:0; transform-origin:0 0; user-select:none; -webkit-user-drag:none; }

    /* markers on screen */
    .calMark {
      position:absolute;
      width: 14px; height: 14px;
      border-radius: 999px;
      border: 3px solid #111;
      background: rgba(255,255,255,0.9);
      transform: translate(-50%, -50%);
      pointer-events:none;
      display:none;
      z-index: 10;
    }
    .calMark.red { border-color:#ff2d2d; }
    .calMark.blue { border-color:#2f6fed; }
    .calMarkLabel {
      position:absolute;
      transform: translate(10px, -14px);
      font-size: 12px;
      font-weight: 900;
      color:#111;
      background: rgba(255,255,255,0.85);
      padding: 2px 6px;
      border-radius: 8px;
      border:1px solid #eee;
      pointer-events:none;
      white-space:nowrap;
    }
  </style>
</head>
<body>

<div id="app">
  <div id="sidebar">
    <h1>–¢—Ä–∞—Ñ–∞—Ä–µ—Ç ‚Üí –ø—Ä–∏–≤—è–∑–∫–∞ ‚Üí —Ñ–∞—Å–∞–¥—ã</h1>
    <div class="muted">
      ‚Ä¢ –ü—Ä–æ–µ–∫—Ç—ã = —Ä–∞–∑–Ω—ã–µ –Ω–∞–±–æ—Ä—ã —Å–ª–æ—ë–≤ (–ü—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å / –ü–ª–æ—Ç–Ω–æ—Å—Ç—å –Ω–∞—Å–µ–ª–µ–Ω–∏—è / ‚Ä¶)<br>
      ‚Ä¢ –¢—Ä–∞—Ñ–∞—Ä–µ—Ç –¥–≤–∏–≥–∞–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–∏–≤—è–∑–∫–æ–π (2 —Ç–æ—á–∫–∏).<br>
      ‚Ä¢ –£–¥–∞–ª–∏—Ç—å –∑–æ–Ω—É: Shift+–∫–ª–∏–∫ –∏–ª–∏ –ü–ö–ú –ø–æ –∑–æ–Ω–µ.
    </div>
    <div id="protoWarn" class="warn"></div>

    <div class="card">
      <div class="label">–ü—Ä–æ–µ–∫—Ç—ã (–Ω–∞–±–æ—Ä—ã —Å–ª–æ—ë–≤)</div>
      <select id="projectSelect"></select>
      <div class="row" style="margin-top:10px">
        <button class="mini primary" id="projNew">Ôºã –ù–æ–≤—ã–π</button>
        <button class="mini" id="projRename">‚úèÔ∏è –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å</button>
        <button class="mini danger" id="projDelete">üóë –£–¥–∞–ª–∏—Ç—å</button>
      </div>
      <div class="small" style="margin-top:8px">
        –ü—Ä–∏–º–µ—Ä: ¬´–ü—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å¬ª, ¬´–ü–ª–æ—Ç–Ω–æ—Å—Ç—å –Ω–∞—Å–µ–ª–µ–Ω–∏—è¬ª, ¬´–†–µ—Å—Ç–æ—Ä–∞–Ω–Ω—ã–µ —É–ª–∏—Ü—ã¬ª.
      </div>
    </div>

    <div class="card">
      <div class="label">–¢—Ä–∞—Ñ–∞—Ä–µ—Ç—ã (—Å–∫—Ä–∏–Ω—ã)</div>
      <button class="btn primary" id="btnAddLayers">üñº –î–æ–±–∞–≤–∏—Ç—å —Å–∫—Ä–∏–Ω(—ã)</button>
      <input id="imgFiles" type="file" accept="image/*" multiple style="display:none">
      <div style="margin-top:10px" id="layersList"></div>
      <div class="small" style="margin-top:8px">
        –î–≤–∏–∂–µ–Ω–∏–µ/–º–∞—Å—à—Ç–∞–± —Ç—Ä–∞—Ñ–∞—Ä–µ—Ç–∞ –Ω–∞ –∫–∞—Ä—Ç–µ –æ—Ç–∫–ª—é—á–µ–Ω—ã ‚Äî —Ç–æ–ª—å–∫–æ –ø—Ä–∏–≤—è–∑–∫–∞ –ø–æ 2 —Ç–æ—á–∫–∞–º.
      </div>
    </div>

    <div class="card">
      <div class="label">–ü—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å (—É—Ä–æ–≤–µ–Ω—å)</div>
      <div class="zones">
        <button class="zonebtn" id="zGreat"  style="border-color:#ff2d2d;">üî¥ 1000+ /—á</button>
        <button class="zonebtn" id="zNormal" style="border-color:#ff8a00;">üü† 500‚Äì1000 /—á</button>
        <button class="zonebtn" id="zMedium" style="border-color:#ffd400;">üü° 100‚Äì500 /—á</button>
        <button class="zonebtn" id="zLow"    style="border-color:#39c16c;">üü¢ 0‚Äì100 /—á</button>
      </div>
      <div class="small" style="margin-top:8px">
        –°–µ–π—á–∞—Å: <b id="stateLine">–≤—ã–∫–ª—é—á–µ–Ω–æ</b>
      </div>
    </div>

    <div class="card">
      <div class="label">–õ–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞ (–æ–¥–Ω–∞ —Å—Ç–æ—Ä–æ–Ω–∞)</div>
      <div class="row">
        <button class="mini ok active" id="sideLeft">‚¨ÖÔ∏è –°–ª–µ–≤–∞ –ø–æ —Ö–æ–¥—É</button>
        <button class="mini ok" id="sideRight">‚û°Ô∏è –°–ø—Ä–∞–≤–∞ –ø–æ —Ö–æ–¥—É</button>
        <button class="mini primary" id="btnFlip">üîÅ Flip</button>
      </div>

      <div style="margin-top:10px">
        <div class="small">–®–∏—Ä–∏–Ω–∞ –∑–∞—Ö–≤–∞—Ç–∞ —Ñ–∞—Å–∞–¥–∞ (–º)</div>
        <input id="streetWidth" type="text" value="15">
      </div>

      <button class="btn primary" id="btnStreetMode" style="margin-top:10px">üñä –í–∫–ª—é—á–∏—Ç—å –ª–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞</button>
      <div class="small" style="margin-top:8px">–†–∏—Å–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è, –ø–æ–∫–∞ –Ω–µ –Ω–∞–∂–º—ë—à—å Esc –∏–ª–∏ –Ω–µ –≤—ã–∫–ª—é—á–∏—à—å –∫–Ω–æ–ø–∫—É.</div>
    </div>

    <div class="card">
      <div class="label">–≠–∫—Å–ø–æ—Ä—Ç / –∏–º–ø–æ—Ä—Ç –∑–æ–Ω (GeoJSON)</div>
      <div class="row">
        <button class="btn" id="btnExport">‚¨áÔ∏è –≠–∫—Å–ø–æ—Ä—Ç</button>
        <button class="btn" id="btnImport">‚¨ÜÔ∏è –ò–º–ø–æ—Ä—Ç</button>
      </div>
      <textarea id="geojsonBox" spellcheck="false" style="margin-top:10px"></textarea>
    </div>
  </div>

  <div id="map"></div>
</div>

<div id="toast" class="toast"></div>

<!-- Calibration modal -->
<div id="calModal">
  <div id="calBox">
    <div class="calTop">
      <div style="font-weight:900">üéØ –ü—Ä–∏–≤—è–∑–∫–∞: –æ—Ç–º–µ—Ç—å —Ç–æ—á–∫–∏ –Ω–∞ —Å–∫—Ä–∏–Ω–µ</div>
      <button id="calClose" class="btn" style="width:auto">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
    <div class="small" id="calHint" style="margin-top:8px"></div>

    <div class="row" style="margin-top:10px">
      <button id="calZoomIn" class="mini primary" style="flex:0 0 auto;">Ôºã</button>
      <button id="calZoomOut" class="mini primary" style="flex:0 0 auto;">Ôºç</button>
      <button id="calZoomFit" class="mini" style="flex:0 0 auto;">–í–ø–∏—Å–∞—Ç—å</button>
      <div class="small" style="align-self:center;">–ö–æ–ª—ë—Å–∏–∫–æ: zoom ‚Ä¢ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ: pan ‚Ä¢ –∫–ª–∏–∫: –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–æ—á–∫—É</div>
    </div>

    <div id="calViewport">
      <div id="calStage">
        <img id="calImg" />
        <div id="markA" class="calMark blue"><div class="calMarkLabel">A</div></div>
        <div id="markB" class="calMark red"><div class="calMarkLabel">B</div></div>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

<script>
  // ========= file:// warning =========
  const protoWarn = document.getElementById("protoWarn");
  if (location.protocol === "file:") {
    protoWarn.style.display = "block";
    protoWarn.innerHTML = `
      –û—Ç–∫—Ä—ã—Ç–æ –∫–∞–∫ <b>file://</b> ‚Äî IndexedDB –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ.<br>
      –ó–∞–ø—É—Å—Ç–∏: <code>python3 -m http.server 8080</code> ‚Üí –æ—Ç–∫—Ä–æ–π <code>http://localhost:8080/stencil-map.html</code>.
    `;
  }

  // ========= Toast =========
  const toast = document.getElementById('toast');
  let toastTimer = null;
  function showToast(text, ms=1600) {
    toast.textContent = text;
    toast.style.display = 'block';
    if (toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.style.display = 'none', ms);
  }

  // ========= Map =========
  const map = L.map('map').setView([59.9386, 30.3141], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20 }).addTo(map);
 

  // ========= Projects =========
  const PROJECTS_KEY = "netwings_projects_v1";
  const ACTIVE_PROJECT_KEY = "netwings_active_project_v1";
  const projectSelect = document.getElementById("projectSelect");

  function genId() { return "id_" + Math.random().toString(16).slice(2) + Date.now().toString(16); }

  function loadProjects() {
    let p = [];
    try { p = JSON.parse(localStorage.getItem(PROJECTS_KEY) || "[]"); } catch(e) {}
    if (!p.length) {
      p = [{ id: genId(), name: "–ü—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å" }];
      localStorage.setItem(PROJECTS_KEY, JSON.stringify(p));
      localStorage.setItem(ACTIVE_PROJECT_KEY, p[0].id);
    }
    return p;
  }
  function saveProjects(list) { localStorage.setItem(PROJECTS_KEY, JSON.stringify(list)); }

  let projects = loadProjects();
  let activeProjectId = localStorage.getItem(ACTIVE_PROJECT_KEY) || projects[0].id;

  function renderProjectSelect() {
    projectSelect.innerHTML = "";
    projects.forEach(pr => {
      const opt = document.createElement("option");
      opt.value = pr.id;
      opt.textContent = pr.name;
      projectSelect.appendChild(opt);
    });
    projectSelect.value = activeProjectId;
  }

  function setActiveProject(pid) {
    activeProjectId = pid;
    localStorage.setItem(ACTIVE_PROJECT_KEY, pid);
    unloadAllLayersFromMap();
    zonesGroup.clearLayers();
    loadZones();
    updateGeo();
    loadLayers().then(() => showToast("–ü—Ä–æ–µ–∫—Ç –ø–µ—Ä–µ–∫–ª—é—á—ë–Ω"));
  }

  document.getElementById("projNew").onclick = () => {
    const name = prompt("–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞:", "–ù–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç");
    if (!name) return;
    const pr = { id: genId(), name: name.trim() };
    projects.unshift(pr);
    saveProjects(projects);
    renderProjectSelect();
    setActiveProject(pr.id);
  };
  document.getElementById("projRename").onclick = () => {
    const pr = projects.find(x => x.id === activeProjectId);
    if (!pr) return;
    const name = prompt("–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:", pr.name);
    if (!name) return;
    pr.name = name.trim();
    saveProjects(projects);
    renderProjectSelect();
  };
  document.getElementById("projDelete").onclick = () => {
    if (projects.length <= 1) { alert("–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–æ–µ–∫—Ç."); return; }
    const pr = projects.find(x => x.id === activeProjectId);
    if (!pr) return;
    if (!confirm(`–£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–µ–∫—Ç "${pr.name}"? (–∑–æ–Ω—ã –∏ —Ç—Ä–∞—Ñ–∞—Ä–µ—Ç—ã —Ç–æ–∂–µ —É–¥–∞–ª—è—Ç—Å—è)`)) return;

    try { localStorage.removeItem(zonesKey()); } catch(e) {}
    try { localStorage.removeItem(metaKey()); } catch(e) {}
    try { localStorage.removeItem(activeKey()); } catch(e) {}

    deleteProjectImages(activeProjectId).finally(() => {
      projects = projects.filter(x => x.id !== activeProjectId);
      saveProjects(projects);
      activeProjectId = projects[0].id;
      localStorage.setItem(ACTIVE_PROJECT_KEY, activeProjectId);
      renderProjectSelect();
      setActiveProject(activeProjectId);
    });
  };

  projectSelect.onchange = (e) => setActiveProject(e.target.value);
  renderProjectSelect();

  // ========= Zones =========
  function zonesKey(){ return `netwings_zones_geojson_v5__${activeProjectId}`; }
  const geojsonBox = document.getElementById("geojsonBox");

  const ZONES = {
    great:  { label: "1000+/—á",    score: 100, color: "#ff2d2d" },
    normal: { label: "500‚Äì1000/—á", score: 70,  color: "#ff8a00" },
    medium: { label: "100‚Äì500/—á",  score: 40,  color: "#ffd400" },
    low:    { label: "0‚Äì100/—á",    score: 10,  color: "#39c16c" }
  };

  let activeZoneKey = null;

  const zonesGroup = new L.FeatureGroup().addTo(map);
  const editOnly = new L.Control.Draw({ edit: { featureGroup: zonesGroup }, draw: false });
  map.addControl(editOnly);

  function styleForFeature(f) {
    const t = f?.properties?.zone_type || "low";
    const z = ZONES[t] || ZONES.low;
    return { color: z.color, weight: 2, fillColor: z.color, fillOpacity: 0.18 };
  }

  function attachDeleteHandlers(layer) {
    layer.on("click", (e) => {
      if (!e?.originalEvent?.shiftKey) return;
      if (confirm("–£–¥–∞–ª–∏—Ç—å —ç—Ç—É –∑–æ–Ω—É?")) {
        zonesGroup.removeLayer(layer);
        updateGeo();
      }
    });
    layer.on("contextmenu", (e) => {
      if (e?.originalEvent) { e.originalEvent.preventDefault(); e.originalEvent.stopPropagation(); }
      if (confirm("–£–¥–∞–ª–∏—Ç—å —ç—Ç—É –∑–æ–Ω—É?")) {
        zonesGroup.removeLayer(layer);
        updateGeo();
      }
    });
  }

  function addGeoJsonToZonesGroup(gj) {
    const layer = L.geoJSON(gj, { style: styleForFeature });
    layer.eachLayer(l => { attachDeleteHandlers(l); zonesGroup.addLayer(l); });
  }

  function updateGeo() {
    const gj = zonesGroup.toGeoJSON();
    geojsonBox.value = JSON.stringify(gj, null, 2);
    try { localStorage.setItem(zonesKey(), JSON.stringify(gj)); } catch(e) {}
  }

  function loadZones() {
    const raw = localStorage.getItem(zonesKey());
    if (!raw) return;
    try { addGeoJsonToZonesGroup(JSON.parse(raw)); } catch(e) {}
  }

  document.getElementById("btnExport").onclick = updateGeo;
  document.getElementById("btnImport").onclick = () => {
    let gj;
    try { gj = JSON.parse(geojsonBox.value || ""); }
    catch(e){ alert("–ù–µ –º–æ–≥—É –ø—Ä–æ—á–∏—Ç–∞—Ç—å JSON."); return; }
    zonesGroup.clearLayers();
    addGeoJsonToZonesGroup(gj);
    updateGeo();
    showToast("–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
  };

  // ========= Level buttons =========
  function clearZoneButtonsUI() {
    document.querySelectorAll(".zonebtn").forEach(b => b.classList.remove("active"));
  }
  function toggleZone(zoneKey) {
    if (activeZoneKey === zoneKey) {
      activeZoneKey = null;
      clearZoneButtonsUI();
      refreshState();
      showToast("–£—Ä–æ–≤–µ–Ω—å —Å–Ω—è—Ç");
      if (streetMode) enableStreetDrawing();
      return;
    }
    activeZoneKey = zoneKey;
    clearZoneButtonsUI();
    const btnId = zoneKey === "great" ? "zGreat" :
                  zoneKey === "normal" ? "zNormal" :
                  zoneKey === "medium" ? "zMedium" : "zLow";
    document.getElementById(btnId).classList.add("active");
    refreshState();
    showToast(`–£—Ä–æ–≤–µ–Ω—å: ${ZONES[zoneKey].label}`);
    if (streetMode) enableStreetDrawing();
  }
  document.getElementById("zGreat").onclick  = () => toggleZone("great");
  document.getElementById("zNormal").onclick = () => toggleZone("normal");
  document.getElementById("zMedium").onclick = () => toggleZone("medium");
  document.getElementById("zLow").onclick    = () => toggleZone("low");

  // ========= Street mode =========
  const stateLine = document.getElementById("stateLine");
  const streetWidthEl = document.getElementById("streetWidth");
  const btnStreetMode = document.getElementById("btnStreetMode");

  let streetMode = false;
  let streetSide = "left";
  let streetDrawer = null;

  let isCalibrating = false;

  function refreshState() {
    const lvl = activeZoneKey ? ZONES[activeZoneKey].label : "–Ω–µ –≤—ã–±—Ä–∞–Ω";
    if (!streetMode) stateLine.textContent = `–≤—ã–∫–ª—é—á–µ–Ω–æ ‚Ä¢ —É—Ä–æ–≤–µ–Ω—å: ${lvl}`;
    else stateLine.textContent = `–ª–∏–Ω–∏–∏ –≤–∫–ª—é—á–µ–Ω—ã ‚Ä¢ —Å—Ç–æ—Ä–æ–Ω–∞: ${streetSide === "left" ? "—Å–ª–µ–≤–∞ –ø–æ —Ö–æ–¥—É" : "—Å–ø—Ä–∞–≤–∞ –ø–æ —Ö–æ–¥—É"} ‚Ä¢ —É—Ä–æ–≤–µ–Ω—å: ${lvl}`;
  }

  const sideLeftBtn = document.getElementById("sideLeft");
  const sideRightBtn = document.getElementById("sideRight");
  function syncSideUI() {
    sideLeftBtn.classList.toggle("active", streetSide === "left");
    sideRightBtn.classList.toggle("active", streetSide === "right");
    refreshState();
  }
  sideLeftBtn.onclick = () => { streetSide = "left"; syncSideUI(); showToast("–°—Ç–æ—Ä–æ–Ω–∞: —Å–ª–µ–≤–∞ –ø–æ —Ö–æ–¥—É"); };
  sideRightBtn.onclick = () => { streetSide = "right"; syncSideUI(); showToast("–°—Ç–æ—Ä–æ–Ω–∞: —Å–ø—Ä–∞–≤–∞ –ø–æ —Ö–æ–¥—É"); };
  document.getElementById("btnFlip").onclick = () => { streetSide = (streetSide === "left") ? "right" : "left"; syncSideUI(); showToast("Flip"); };

  function parseStreetWidthMeters() {
    const w = Number(String(streetWidthEl.value || "15").trim().replace(",", "."));
    if (!Number.isFinite(w)) return 15;
    return Math.max(2, Math.min(60, w));
  }

  function disableStreetDrawing() { try { if (streetDrawer) streetDrawer.disable(); } catch(e) {} }

  function enableStreetDrawing() {
    disableStreetDrawing();
    if (!streetMode) return;
    if (isCalibrating) return;
    if (!activeZoneKey) { showToast("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —É—Ä–æ–≤–µ–Ω—å üî¥üü†üü°üü¢", 1800); return; }
    if (!streetDrawer) streetDrawer = new L.Draw.Polyline(map, { shapeOptions: {} });
    try { streetDrawer.enable(); } catch(e) {}
  }

  btnStreetMode.onclick = () => {
    streetMode = !streetMode;
    if (streetMode) {
      btnStreetMode.textContent = "üü© –õ–∏–Ω–∏–∏ –≤–∫–ª—é—á–µ–Ω—ã (—Ä–∏—Å—É–π)";
      enableStreetDrawing();
      showToast("–†–∏—Å—É–π –ª–∏–Ω–∏—é ‚Äî —Å–æ–∑–¥–∞—Å—Ç—Å—è –ø–æ–ª–æ—Å–∞ —Ñ–∞—Å–∞–¥–∞", 1800);
    } else {
      btnStreetMode.textContent = "üñä –í–∫–ª—é—á–∏—Ç—å –ª–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞";
      disableStreetDrawing();
      showToast("–õ–∏–Ω–∏–∏ –≤—ã–∫–ª—é—á–µ–Ω—ã");
    }
    refreshState();
  };

  function makeOneSidedFacadePolygon(lineFeature, widthMeters, side) {
    const halfKm = (widthMeters / 2) / 1000;
    const sign = (side === "left") ? -1 : +1; // —Ñ–∏–∫—Å —Å–ª–µ–≤–∞/—Å–ø—Ä–∞–≤–∞
    const offsetLine = turf.lineOffset(lineFeature, sign * halfKm, { units: "kilometers" });
    return turf.buffer(offsetLine, halfKm, { units: "kilometers" });
  }

  function makeProps(zoneKey) {
    const z = ZONES[zoneKey];
    return {
      zone_type: zoneKey,
      zone_label: z.label,
      zone_score: z.score,
      mode: "street_facade",
      street_side: (streetSide === "left") ? "left_of_draw" : "right_of_draw",
      facade_width_m: parseStreetWidthMeters()
    };
  }

  map.on(L.Draw.Event.CREATED, (event) => {
    if (!streetMode) return;
    if (!activeZoneKey) { try { event.layer.remove(); } catch(_) {} return; }

    const w = parseStreetWidthMeters();
    const z = ZONES[activeZoneKey];

    const line = event.layer.toGeoJSON();
    let poly;
    try { poly = makeOneSidedFacadePolygon(line, w, streetSide); }
    catch (e) { alert("–ù–µ —Å–º–æ–≥ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –ø–æ–ª–æ—Å—É. –ù–∞—Ä–∏—Å—É–π –ª–∏–Ω–∏—é —á—É—Ç—å –¥–ª–∏–Ω–Ω–µ–µ."); return; }

    const polyLayer = L.geoJSON(poly, {
      style: { color: z.color, weight: 2, fillColor: z.color, fillOpacity: 0.18 }
    });

    polyLayer.eachLayer(l => {
      l.feature = l.feature || { type:"Feature", properties:{}, geometry:null };
      Object.assign(l.feature.properties, makeProps(activeZoneKey));
      attachDeleteHandlers(l);
      zonesGroup.addLayer(l);
    });

    updateGeo();
    setTimeout(() => { if (streetMode) enableStreetDrawing(); }, 0);
  });

  // ESC
  window.addEventListener("keydown", (ev) => {
    if (ev.key === "Escape") {
      ev.preventDefault();
      streetMode = false;
      btnStreetMode.textContent = "üñä –í–∫–ª—é—á–∏—Ç—å –ª–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞";
      disableStreetDrawing();
      refreshState();
      stopCalibrate();
      closeCalModal();
      showToast("–í—ã–∫–ª—é—á–µ–Ω–æ (Esc)");
    }
  }, { passive:false });

  // ========= IndexedDB (images) =========
  const DB_NAME = "netwings_stencil_db_v4";
  const DB_STORE = "layers";
  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE, { keyPath: "key" });
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function layerKey(projectId, layerId){ return `${projectId}:${layerId}`; }

  async function idbPutLayer(projectId, layerId, dataUrl) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).put({ key: layerKey(projectId, layerId), projectId, layerId, dataUrl });
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }
  async function idbGetLayer(projectId, layerId) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).get(layerKey(projectId, layerId));
      req.onsuccess = () => resolve(req.result?.dataUrl || null);
      req.onerror = () => reject(req.error);
    });
  }
  async function idbDeleteLayer(projectId, layerId) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).delete(layerKey(projectId, layerId));
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }
  async function deleteProjectImages(projectId) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readwrite");
      const store = tx.objectStore(DB_STORE);
      const req = store.openCursor();
      req.onsuccess = () => {
        const cursor = req.result;
        if (!cursor) return;
        const v = cursor.value;
        if (v?.projectId === projectId) cursor.delete();
        cursor.continue();
      };
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }

  // ========= Layers =========
  function metaKey(){ return `netwings_stencil_layers_meta_v4__${activeProjectId}`; }
  function activeKey(){ return `netwings_stencil_layers_active_v4__${activeProjectId}`; }

  const layersList = document.getElementById("layersList");
  const btnAddLayers = document.getElementById("btnAddLayers");
  const imgFiles = document.getElementById("imgFiles");

  let layers = [];
  let activeLayerId = null;

  function fileToDataURL(file) {
    return new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onerror = () => reject(new Error("FileReader error"));
      r.onload  = () => resolve(r.result);
      r.readAsDataURL(file);
    });
  }

  function serializeBounds(bounds) {
    const sw = bounds.getSouthWest();
    const ne = bounds.getNorthEast();
    return { sw: {lat: sw.lat, lng: sw.lng}, ne: {lat: ne.lat, lng: ne.lng} };
  }
  function deserializeBounds(obj) {
    return L.latLngBounds([obj.sw.lat, obj.sw.lng], [obj.ne.lat, obj.ne.lng]);
  }

  function saveMeta() {
    const payload = layers.map(l => ({
      id: l.id, name: l.name, opacity: l.opacity, bounds: l.boundsObj
    }));
    localStorage.setItem(metaKey(), JSON.stringify(payload));
    localStorage.setItem(activeKey(), activeLayerId || "");
  }

  function getLayer(id) { return layers.find(x => x.id === id) || null; }

  function setActiveLayer(id) {
    activeLayerId = id;
    layers.forEach(l => l.overlay.setZIndex(l.id === activeLayerId ? 1000 : 500));
    renderLayersList();
    saveMeta();
  }

  function updateOpacity(id, opacity01) {
    const l = getLayer(id);
    if (!l) return;
    l.opacity = opacity01;
    l.overlay.setOpacity(opacity01);
    saveMeta();
  }

  async function deleteLayer(id) {
    const idx = layers.findIndex(x => x.id === id);
    if (idx < 0) return;
    const l = layers[idx];
    map.removeLayer(l.overlay);
    layers.splice(idx, 1);
    await idbDeleteLayer(activeProjectId, id);
    if (activeLayerId === id) activeLayerId = layers.length ? layers[0].id : null;
    saveMeta();
    renderLayersList();
  }

  function renderLayersList() {
    layersList.innerHTML = "";
    if (!layers.length) {
      layersList.innerHTML = `<div class="small">–¢—Ä–∞—Ñ–∞—Ä–µ—Ç–æ–≤ –Ω–µ—Ç. –ù–∞–∂–º–∏ ‚Äú–î–æ–±–∞–≤–∏—Ç—å —Å–∫—Ä–∏–Ω(—ã)‚Äù.</div>`;
      return;
    }

    layers.forEach(l => {
      const isActive = l.id === activeLayerId;

      const item = document.createElement("div");
      item.className = "layerItem" + (isActive ? " active" : "");
      item.onclick = () => setActiveLayer(l.id);

      const top = document.createElement("div");
      top.className = "layerTop";

      const name = document.createElement("div");
      name.className = "layerName";
      name.textContent = l.name || "–¢—Ä–∞—Ñ–∞—Ä–µ—Ç";

      const pill = document.createElement("div");
      pill.className = "pill";
      pill.textContent = "–¢–æ–ª—å–∫–æ –ø—Ä–∏–≤—è–∑–∫–∞";

      top.appendChild(name);
      top.appendChild(pill);

      const btnRow = document.createElement("div");
      btnRow.className = "row";

      const bCal = document.createElement("button");
      bCal.className = "mini primary";
      bCal.textContent = "üéØ –ü—Ä–∏–≤—è–∑–∫–∞ (2 —Ç–æ—á–∫–∏)";
      bCal.onclick = (e) => { e.stopPropagation(); if (!isActive) setActiveLayer(l.id); startCalibrate(l.id); };

      const bDel = document.createElement("button");
      bDel.className = "mini danger";
      bDel.textContent = "–£–¥–∞–ª–∏—Ç—å";
      bDel.onclick = (e) => { e.stopPropagation(); deleteLayer(l.id); };

      btnRow.appendChild(bCal);
      btnRow.appendChild(bDel);

      const opacityWrap = document.createElement("div");
      opacityWrap.innerHTML = `<div class="small">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å</div>`;
      const range = document.createElement("input");
      range.type = "range";
      range.min = "0";
      range.max = "100";
      range.value = String(Math.round((l.opacity ?? 0.5) * 100));
      range.oninput = (e) => { e.stopPropagation(); updateOpacity(l.id, Number(e.target.value)/100); };
      opacityWrap.appendChild(range);

      const renameWrap = document.createElement("div");
      renameWrap.innerHTML = `<div class="small" style="margin-top:8px">–ù–∞–∑–≤–∞–Ω–∏–µ</div>`;
      const rename = document.createElement("input");
      rename.type = "text";
      rename.value = l.name || "";
      rename.placeholder = "–Ω–∞–ø—Ä–∏–º–µ—Ä: –¢—Ä–∞—Ñ–∞—Ä–µ—Ç —Ç—Ä–∞—Ñ–∏–∫–∞";
      rename.oninput = (e) => { e.stopPropagation(); l.name = e.target.value; saveMeta(); };
      renameWrap.appendChild(rename);

      item.appendChild(top);
      item.appendChild(btnRow);
      item.appendChild(opacityWrap);
      item.appendChild(renameWrap);

      layersList.appendChild(item);
    });
  }

  async function addLayerFromDataUrl(dataUrl) {
    const id = genId();
    const bounds = map.getBounds();
    await idbPutLayer(activeProjectId, id, dataUrl);

    const overlay = L.imageOverlay(dataUrl, bounds, { opacity: 0.5, interactive: true }).addTo(map);
    overlay.on("click", () => setActiveLayer(id));

    const layerObj = { id, name: "–¢—Ä–∞—Ñ–∞—Ä–µ—Ç", opacity: 0.5, boundsObj: serializeBounds(bounds), overlay, dataUrl };
    layers.unshift(layerObj);
    activeLayerId = id;
    saveMeta();
    renderLayersList();
    showToast("–¢—Ä–∞—Ñ–∞—Ä–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω ‚Üí —Å–¥–µ–ª–∞–π –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å ‚Üí –ø—Ä–∏–≤—è–∂–∏ –ø–æ 2 —Ç–æ—á–∫–∞–º", 2200);
  }

  function unloadAllLayersFromMap() {
    try { layers.forEach(l => { try { map.removeLayer(l.overlay); } catch(_) {} }); } catch(_) {}
    layers = [];
    activeLayerId = null;
    renderLayersList();
  }

  async function loadLayers() {
    const rawMeta = localStorage.getItem(metaKey());
    let meta = [];
    try { meta = rawMeta ? (JSON.parse(rawMeta) || []) : []; } catch(e) { meta = []; }

    layers = [];
    for (const m of meta) {
      const dataUrl = await idbGetLayer(activeProjectId, m.id);
      if (!dataUrl) continue;

      const bounds = deserializeBounds(m.bounds);
      const overlay = L.imageOverlay(dataUrl, bounds, {
        opacity: typeof m.opacity === "number" ? m.opacity : 0.5,
        interactive: true
      }).addTo(map);
      overlay.on("click", () => setActiveLayer(m.id));

      layers.push({
        id: m.id,
        name: m.name || "–¢—Ä–∞—Ñ–∞—Ä–µ—Ç",
        opacity: typeof m.opacity === "number" ? m.opacity : 0.5,
        boundsObj: m.bounds,
        overlay,
        dataUrl
      });
    }

    const savedActive = localStorage.getItem(activeKey()) || "";
    activeLayerId = (savedActive && getLayer(savedActive)) ? savedActive : (layers[0]?.id || null);
    renderLayersList();
  }

  btnAddLayers.onclick = () => { imgFiles.value = ""; imgFiles.click(); };
  imgFiles.onchange = async (e) => {
    const files = Array.from(e.target.files || []);
    if (!files.length) return;
    for (const f of files) {
      const dataUrl = await fileToDataURL(f);
      await addLayerFromDataUrl(dataUrl);
    }
  };

  // ========= Calibration modal =========
  const calModal = document.getElementById("calModal");
  const calHint = document.getElementById("calHint");
  const calImg = document.getElementById("calImg");
  const calViewport = document.getElementById("calViewport");
  const calStage = document.getElementById("calStage");

  const calZoomIn = document.getElementById("calZoomIn");
  const calZoomOut = document.getElementById("calZoomOut");
  const calZoomFit = document.getElementById("calZoomFit");

  const markA = document.getElementById("markA");
  const markB = document.getElementById("markB");

  function metersToLat(m) { return m / 111320; }
  function metersToLng(m, atLat) { return m / (111320 * Math.cos(atLat * Math.PI/180)); }

  let calZoom = 1, calPanX = 0, calPanY = 0;
  let calMinZoom = 1, calMaxZoom = 12;

  function applyCalTransform() {
    calImg.style.transform = `translate(${calPanX}px, ${calPanY}px) scale(${calZoom})`;
    // –º–∞—Ä–∫–µ—Ä—ã –¥–æ–ª–∂–Ω—ã –¥–≤–∏–≥–∞—Ç—å—Å—è –≤–º–µ—Å—Ç–µ —Å –∫–∞—Ä—Ç–∏–Ω–∫–æ–π, –ø–æ—ç—Ç–æ–º—É —Å—Ç–∞–≤–∏–º –∏—Ö –≤ "—ç–∫—Ä–∞–Ω–Ω—ã—Ö" –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö –Ω–∏–∂–µ (setScreenMarker)
  }

  function getFitZoom() {
    const vw = calViewport.clientWidth;
    const vh = calViewport.clientHeight;
    const iw = calImg.naturalWidth || 1;
    const ih = calImg.naturalHeight || 1;
    return Math.max(vw / iw, vh / ih);
  }

  function clampPan() {
    const vw = calViewport.clientWidth;
    const vh = calViewport.clientHeight;
    const iw = (calImg.naturalWidth || 1) * calZoom;
    const ih = (calImg.naturalHeight || 1) * calZoom;

    const minX = vw - iw;
    const minY = vh - ih;

    calPanX = Math.min(0, Math.max(minX, calPanX));
    calPanY = Math.min(0, Math.max(minY, calPanY));
  }

  function setZoom(newZoom, anchorX, anchorY) {
    const prevZoom = calZoom;
    calZoom = Math.max(calMinZoom, Math.min(calMaxZoom, newZoom));
    const k = calZoom / prevZoom;
    calPanX = anchorX - (anchorX - calPanX) * k;
    calPanY = anchorY - (anchorY - calPanY) * k;
    clampPan();
    applyCalTransform();
    refreshMarkers();
  }

  function fitAndCenter() {
    calMinZoom = getFitZoom();
    calZoom = calMinZoom;

    const vw = calViewport.clientWidth;
    const vh = calViewport.clientHeight;
    const iw = (calImg.naturalWidth || 1) * calZoom;
    const ih = (calImg.naturalHeight || 1) * calZoom;

    calPanX = (vw - iw) / 2;
    calPanY = (vh - ih) / 2;
    clampPan();
    applyCalTransform();
    refreshMarkers();
  }

  function openCalModal(text) {
    calHint.innerHTML = text;
    calModal.style.display = "block";
  }
  function closeCalModal() { calModal.style.display = "none"; }
  document.getElementById("calClose").onclick = () => { stopCalibrate(); closeCalModal(); };

  calZoomIn.onclick = () => setZoom(calZoom * 1.15, calViewport.clientWidth/2, calViewport.clientHeight/2);
  calZoomOut.onclick = () => setZoom(calZoom / 1.15, calViewport.clientWidth/2, calViewport.clientHeight/2);
  calZoomFit.onclick = () => fitAndCenter();

  calViewport.addEventListener("wheel", (e) => {
    if (calModal.style.display !== "block") return;
    e.preventDefault();
    const rect = calViewport.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const factor = e.deltaY < 0 ? 1.12 : 1/1.12;
    setZoom(calZoom * factor, cx, cy);
  }, { passive:false });

  // --- New pointer logic (fix for Mac trackpad): click is detected on pointerup if moved <= 8px
  let panPointerId = null;
  let panStart = null;
  const CLICK_TOLERANCE_PX = 8;

  function viewportPointFromClient(clientX, clientY) {
    const rect = calViewport.getBoundingClientRect();
    return { vx: clientX - rect.left, vy: clientY - rect.top };
  }

  function imgPointFromViewport(vx, vy) {
    const x = (vx - calPanX) / calZoom;
    const y = (vy - calPanY) / calZoom;
    return { x, y };
  }

  function setMarker(el, pxPoint, labelVisible) {
    if (!pxPoint) { el.style.display = "none"; return; }
    // –ø–µ—Ä–µ–≤–æ–¥–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–∞—Ä—Ç–∏–Ω–∫–∏ -> –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã viewport (—ç–∫—Ä–∞–Ω)
    const vx = pxPoint.x * calZoom + calPanX;
    const vy = pxPoint.y * calZoom + calPanY;
    el.style.left = `${vx}px`;
    el.style.top  = `${vy}px`;
    el.style.display = "block";
  }

  function refreshMarkers() {
    setMarker(markA, calState.imgA, true);
    setMarker(markB, calState.imgB, true);
  }

  function tryHandleScreenClick(clientX, clientY) {
    const { vx, vy } = viewportPointFromClient(clientX, clientY);
    const p = imgPointFromViewport(vx, vy);

    if (p.x < 0 || p.y < 0 || p.x > calImg.naturalWidth || p.y > calImg.naturalHeight) {
      showToast("–ö–ª–∏–∫–Ω–∏ –ø–æ —Å–∞–º–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–µ", 1200);
      return;
    }

    if (!calState.active) return;

    if (calState.step === 2) {
      calState.imgA = { x: p.x, y: p.y };
      refreshMarkers();
      calState.step = 3;
      closeCalModal();
      showToast("–®–∞–≥ 3/4: –∫–ª–∏–∫–Ω–∏ –¢–û–ß–ö–£ B –Ω–∞ –ö–ê–†–¢–ï", 2200);
      return;
    }

    if (calState.step === 4) {
      calState.imgB = { x: p.x, y: p.y };
      refreshMarkers();
      closeCalModal();
      applyCalibration();
      stopCalibrate();
      return;
    }
  }

  calStage.addEventListener("pointerdown", (e) => {
    if (calModal.style.display !== "block") return;
    panPointerId = e.pointerId;
    calStage.setPointerCapture(panPointerId);
    calStage.style.cursor = "grabbing";

    panStart = {
      x: e.clientX, y: e.clientY,
      panX: calPanX, panY: calPanY
    };
  });

  calStage.addEventListener("pointermove", (e) => {
    if (panPointerId === null || e.pointerId !== panPointerId) return;
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    calPanX = panStart.panX + dx;
    calPanY = panStart.panY + dy;
    clampPan();
    applyCalTransform();
    refreshMarkers();
  });

  calStage.addEventListener("pointerup", (e) => {
    if (panPointerId === null || e.pointerId !== panPointerId) return;

    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;

    calStage.style.cursor = "grab";
    try { calStage.releasePointerCapture(panPointerId); } catch(_) {}
    panPointerId = null;

    // –µ—Å–ª–∏ –ø–æ—á—Ç–∏ –Ω–µ –¥–≤–∏–≥–∞–ª–∏ ‚Äî —ç—Ç–æ –∫–ª–∏–∫
    if (Math.hypot(dx, dy) <= CLICK_TOLERANCE_PX) {
      tryHandleScreenClick(e.clientX, e.clientY);
    }
  });

  // ========= Calibration state =========
  const calState = {
    active: false,
    layerId: null,
    step: 0, // 1 mapA, 2 imgA, 3 mapB, 4 imgB
    mapA: null,
    mapB: null,
    imgA: null,
    imgB: null
  };

  function startCalibrate(layerId) {
    const l = getLayer(layerId);
    if (!l) return;
    setActiveLayer(layerId);

    isCalibrating = true;
    disableStreetDrawing();

    calState.active = true;
    calState.layerId = layerId;
    calState.step = 1;
    calState.mapA = calState.mapB = null;
    calState.imgA = calState.imgB = null;
    refreshMarkers();

    closeCalModal();
    showToast("–ü—Ä–∏–≤—è–∑–∫–∞: –∫–ª–∏–∫–Ω–∏ —Ç–æ—á–∫—É A –Ω–∞ –ö–ê–†–¢–ï", 2200);
  }

  function stopCalibrate() {
    calState.active = false;
    calState.layerId = null;
    calState.step = 0;
    calState.mapA = calState.mapB = null;
    calState.imgA = calState.imgB = null;
    refreshMarkers();

    isCalibrating = false;
    if (streetMode) enableStreetDrawing();
  }

  function mapDistanceMeters(a, b) {
    const km = turf.distance(turf.point([a.lng, a.lat]), turf.point([b.lng, b.lat]), { units:"kilometers" });
    return km * 1000;
  }
  function pixelDistance(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function applyCalibration() {
    const l = getLayer(calState.layerId);
    if (!l) return;

    const mA = calState.mapA, mB = calState.mapB;
    const pA = calState.imgA, pB = calState.imgB;

    const dM = mapDistanceMeters(mA, mB);
    const dP = pixelDistance(pA, pB);
    if (!dP || dP < 2) { alert("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏ –Ω–∞ —Å–∫—Ä–∏–Ω–µ."); return; }

    const metersPerPixel = dM / dP;
    const W = calImg.naturalWidth;
    const H = calImg.naturalHeight;

    function pxToLatLng(dxPx, dyPx) {
      const dxM = dxPx * metersPerPixel;
      const dyM = dyPx * metersPerPixel;
      const dLat = -metersToLat(dyM);
      const dLng = metersToLng(dxM, mA.lat);
      return { lat: mA.lat + dLat, lng: mA.lng + dLng };
    }

    const tl = pxToLatLng(0 - pA.x, 0 - pA.y);
    const tr = pxToLatLng(W - pA.x, 0 - pA.y);
    const bl = pxToLatLng(0 - pA.x, H - pA.y);
    const br = pxToLatLng(W - pA.x, H - pA.y);

    const minLat = Math.min(tl.lat, tr.lat, bl.lat, br.lat);
    const maxLat = Math.max(tl.lat, tr.lat, bl.lat, br.lat);
    const minLng = Math.min(tl.lng, tr.lng, bl.lng, br.lng);
    const maxLng = Math.max(tl.lng, tr.lng, bl.lng, br.lng);

    const bounds = L.latLngBounds([minLat, minLng], [maxLat, maxLng]);
    l.overlay.setBounds(bounds);
    l.boundsObj = serializeBounds(bounds);
    saveMeta();

    showToast("–ü—Ä–∏–≤—è–∑–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∞ ‚úÖ", 2000);
  }

  // Map clicks for calibration
  map.on("click", (e) => {
    if (!calState.active) return;

    if (calState.step === 1) {
      calState.mapA = e.latlng;
      calState.step = 2;

      const l = getLayer(calState.layerId);
      calImg.src = l.dataUrl;
      calImg.onload = () => {
        openCalModal("–®–∞–≥ 2/4: –∫–ª–∏–∫–Ω–∏ –¢–û–ß–ö–£ A –Ω–∞ –°–ö–†–ò–ù–ï (–º–æ–∂–Ω–æ –ø—Ä–∏–±–ª–∏–∂–∞—Ç—å/–ø–∞–Ω–∏—Ç—å).");
        fitAndCenter();
        refreshMarkers();
      };
      return;
    }

    if (calState.step === 3) {
      calState.mapB = e.latlng;
      calState.step = 4;

      const l = getLayer(calState.layerId);
      calImg.src = l.dataUrl;
      calImg.onload = () => {
        openCalModal("–®–∞–≥ 4/4: –∫–ª–∏–∫–Ω–∏ –¢–û–ß–ö–£ B –Ω–∞ –°–ö–†–ò–ù–ï (–ø–æ—Å–ª–µ –∫–ª–∏–∫–∞ –ø—Ä–∏–≤—è–∑–∫–∞ –ø—Ä–∏–º–µ–Ω–∏—Ç—Å—è).");
        fitAndCenter();
        refreshMarkers();
      };
      return;
    }
  });

  // ========= Init =========
  loadZones();
  updateGeo();
  syncSideUI();
  refreshState();

  loadLayers().then(() => {
    showToast("–ì–æ—Ç–æ–≤–æ. –ü—Ä–æ–µ–∫—Ç ‚Üí —Ç—Ä–∞—Ñ–∞—Ä–µ—Ç ‚Üí –ø—Ä–∏–≤—è–∑–∫–∞ ‚Üí –ª–∏–Ω–∏–∏ —Ñ–∞—Å–∞–¥–∞.", 2400);
  });
</script>

</body>
</html>
